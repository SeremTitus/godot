/**************************************************************************/
/*  gdscript_cpp_gen.cpp                                                  */
/**************************************************************************/
/*                         This file is part of:                          */
/*                             GODOT ENGINE                               */
/*                        https://godotengine.org                         */
/**************************************************************************/
/* Copyright (c) 2014-present Godot Engine contributors (see AUTHORS.md). */
/* Copyright (c) 2007-2014 Juan Linietsky, Ariel Manzur.                  */
/*                                                                        */
/* Permission is hereby granted, free of charge, to any person obtaining  */
/* a copy of this software and associated documentation files (the        */
/* "Software"), to deal in the Software without restriction, including    */
/* without limitation the rights to use, copy, modify, merge, publish,    */
/* distribute, sublicense, and/or sell copies of the Software, and to     */
/* permit persons to whom the Software is furnished to do so, subject to  */
/* the following conditions:                                              */
/*                                                                        */
/* The above copyright notice and this permission notice shall be         */
/* included in all copies or substantial portions of the Software.        */
/*                                                                        */
/* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,        */
/* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF     */
/* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. */
/* IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY   */
/* CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,   */
/* TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE      */
/* SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.                 */
/**************************************************************************/

#include "gdscript_cpp_gen.h"

#include "core/io/file_access.h"
#include "core/object/ref_counted.h"
#include "gdscript_cache.h"

void GDScriptCPPGen::setup_output_folder() {
	if (!DirAccess::exists(output_folder.path_join("gen"))) {
		Error err = DirAccess::make_dir_recursive_absolute(output_folder.path_join("gen"));
		ERR_FAIL_COND_MSG(err != OK, "Failed to create output folder: " + output_folder);
	}

	// Broken: zero action to get the godot-cpp by git
	String godot_cpp_folder = output_folder.path_join("godot-cpp");
	if (!DirAccess::exists(godot_cpp_folder)) {
		if (OS::get_singleton()->execute("git", { "--version" }) != 0) {
			ERR_FAIL_MSG("Git is not installed or not found in the system PATH. Please install Git to use GDScriptCPPGen.");
		}

		if (OS::get_singleton()->execute(
					"git",
					{ "clone", "--depth", "1", "https://github.com/godotengine/godot-cpp.git", godot_cpp_folder }) != 0) {
			ERR_FAIL_MSG("Failed to clone godot-cpp extension.");
		}
		// "-b", "4.4"

		if (OS::get_singleton()->execute(
					"git",
					{ "submodule", "update", "--init", "--depth", "1", godot_cpp_folder }) != 0) {
			ERR_FAIL_MSG("Failed to update git submodules for godot-cpp.");
		}

		String godot_exe_path = OS::get_singleton()->get_executable_path();
		print_line("Godot executable path: " + godot_exe_path);
		if (OS::get_singleton()->execute(godot_exe_path, { "--headless", "--dump-extension-api", "--dump-gdextension-interface" }) == 0) {
			print_line("dumped extension API and GDExtension interface.");
		}
	}

	if (!FileAccess::exists(output_folder.path_join("SConstruct"))) {
		Ref<FileAccess> file = FileAccess::open(output_folder.path_join("SConstruct"), FileAccess::WRITE);
		if (file.is_valid()) {
			file->store_string("# This file is generated by GDScriptCPPGen.\n");
			file->store_string(String(R"(
				#!/usr/bin/env python
				import os
				import sys

				env = SConscript("godot-cpp/SConstruct")

				# For reference:
				# - CCFLAGS are compilation flags shared between C and C++
				# - CFLAGS are for C-specific compilation flags
				# - CXXFLAGS are for C++-specific compilation flags
				# - CPPFLAGS are for pre-processor flags
				# - CPPDEFINES are for pre-processor defines
				# - LINKFLAGS are for linking flags

				env.Append(CPPPATH=["gen/"])
				sources = Glob("gen/*.cpp")

				if env["platform"] == "macos":
					library = env.SharedLibrary(
						"bin/gdscript_cpp.{}.{}.framework/gdscript_cpp.{}.{}".format(
							env["platform"], env["target"], env["platform"], env["target"]
						),
						source=sources,
					)
				elif env["platform"] == "ios":
					if env["ios_simulator"]:
						library = env.StaticLibrary(
							"bin/gdscript_cpp.{}.{}.simulator.a".format(env["platform"], env["target"]),
							source=sources,
						)
					else:
						library = env.StaticLibrary(
							"bin/gdscript_cpp.{}.{}.a".format(env["platform"], env["target"]),
							source=sources,
						)
				else:
					library = env.SharedLibrary(
						"bin/gdscript_cpp{}{}".format(env["suffix"], env["SHLIBSUFFIX"]),
						source=sources,
					)

				Default(library)
			)")
							.dedent());
			file->close();
		} else {
			ERR_PRINT("Failed to open file: SConstruct");
		}
	}

	if (!FileAccess::exists(output_folder.path_join("gen").path_join("gdscript.h"))) {
		Ref<FileAccess> file = FileAccess::open(output_folder.path_join("gen").path_join("gdscript.h"), FileAccess::WRITE);
		if (file.is_valid()) {
			file->store_string("# This file is generated by GDScriptCPPGen.\n");
			file->store_string(String(R"(
				#include <godot_cpp/variant/variant.hpp>
				#include <godot_cpp/variant/typed_dictionary.hpp>
				#include <godot_cpp/variant/color.hpp>
				#include <godot_cpp/variant/utility_functions.hpp>
				#include <godot_cpp/classes/resource_loader.hpp>
				#include <godot_cpp/classes/packed_scene.hpp>
				#include <godot_cpp/classes/object.hpp>
				#include <godot_cpp/classes/node.hpp>
				#include <godot_cpp/core/class_db.hpp>
				#include <godot_cpp/core/memory.hpp>
				#include <godot_cpp/classes/json.hpp>
				#include <godot_cpp/variant/array.hpp>
				#include <godot_cpp/variant/string.hpp>
				#include <godot_cpp/Core/math_defs.hpp>

				#include <cmath>
				#include <initializer_list>
				#include <string>

				using namespace godot;
				using namespace std;

				// === Dictionary Helper ===
				inline Dictionary make_dict(initializer_list<pair<const Variant, Variant>> init)
				{
					Dictionary dict;
					for (const auto &p : init)
					{
						dict[p.first] = p.second;
					}
					return dict;
				}

				// ====================================================================
				// GDExtension Helper Functions (Mimicking GDScript)
				// ====================================================================

				const double PI = Math_PI;
				const double TAU = Math_TAU;
				const double INF = Math_INF;

				inline Variant abs(const Variant &x)
				{
					switch (x.get_type())
					{
					case Variant::INT:
						return Variant(Math::abs((int64_t)x));
					case Variant::FLOAT:
						return Variant(Math::abs((double)x));
					default:
						UtilityFunctions::printerr("abs(): unsupported Variant type");
						return Variant();
					}
				}

				inline int len(const Variant &x)
				{
					switch (x.get_type())
					{
					case Variant::STRING:
					case Variant::STRING_NAME:
						return ((String)x).length();
					case Variant::ARRAY:
						return ((Array)x).size();
					case Variant::DICTIONARY:
						return ((Dictionary)x).size();
					case Variant::PACKED_BYTE_ARRAY:
						return ((PackedByteArray)x).size();
					case Variant::PACKED_INT32_ARRAY:
						return ((PackedInt32Array)x).size();
					case Variant::PACKED_INT64_ARRAY:
						return ((PackedInt64Array)x).size();
					case Variant::PACKED_FLOAT32_ARRAY:
						return ((PackedFloat32Array)x).size();
					case Variant::PACKED_FLOAT64_ARRAY:
						return ((PackedFloat64Array)x).size();
					case Variant::PACKED_STRING_ARRAY:
						return ((PackedStringArray)x).size();
					case Variant::PACKED_VECTOR2_ARRAY:
						return ((PackedVector2Array)x).size();
					case Variant::PACKED_VECTOR3_ARRAY:
						return ((PackedVector3Array)x).size();
					case Variant::PACKED_VECTOR4_ARRAY:
						return ((PackedVector4Array)x).size();
					case Variant::PACKED_COLOR_ARRAY:
						return ((PackedColorArray)x).size();
					default:
						UtilityFunctions::printerr("len(): unsupported Variant type");
						return -1;
					}
				}

				inline String chr(int code)
				{
					return String::chr(code);
				}

				inline int ord(const String chr)
				{
					return chr.unicode_at(0);
				}

				inline Color Color8(int r8, int g8, int b8, int a8 = 255)
				{
					return Color::from_rgba8(r8, g8, b8, a8);
				}

				inline Array range(int n)
				{
					Array arr;
					for (int i = 0; i < n; i++)
						arr.push_back(i);
					return arr;
				}

				inline Array range(int b, int n)
				{
					Array arr;
					for (int i = b; i < n; i++)
						arr.push_back(i);
					return arr;
				}

				inline Array range(int b, int n, int s)
				{
					Array arr;
					if (s == 0)
					{
						UtilityFunctions::printerr("range(): step cannot be zero");
						return arr;
					}
					if (s > 0)
					{
						for (int i = b; i < n; i += s)
							arr.push_back(i);
					}
					else
					{
						for (int i = b; i > n; i += s)
							arr.push_back(i);
					}
					return arr;
				}

				inline bool type_exists(const StringName &type)
				{
					return ClassDB::class_exists(type);
				}

				inline bool is_instance_of(const Variant &value, const Variant &type)
				{
					if (type.get_type() == Variant::INT)
					{
						return value.get_type() == (Variant::Type)(int)type;
					}
					if (type.get_type() == Variant::STRING_NAME)
					{
						StringName class_name = type;
						return ClassDB::class_exists(class_name) && value.get_type() == Variant::OBJECT &&
							Object::cast_to<Object>(value) != nullptr;
					}
					return false;
				}

				inline Ref<Resource> load(const String &path)
				{
					return ResourceLoader::get_singleton()->load(path);
				}

				inline Dictionary inst_to_dict(const Variant &obj)
				{
					Variant json_variant = JSON::from_native(obj, true);
					String json_str = JSON::stringify(json_variant);

					Dictionary dict;
					dict["data"] = json_str;
					return dict;
				}

				inline Variant dict_to_inst(const Dictionary &dict)
				{
					if (!dict.has("data"))
					{
						return Variant();
					}

					String json_str = dict["data"];
					Variant parsed = JSON::parse_string(json_str);

					if (parsed.get_type() == Variant::NIL)
					{
						UtilityFunctions::push_error("decode_data: Failed to parse JSON string");
						return Variant();
					}
					return JSON::to_native(parsed, true);
				}

				inline Variant convert(const Variant &what, Variant::Type type)
				{
					return what;
				}

				template <typename... Args>
				inline void print_debug(const Args &...args)
				{
					UtilityFunctions::print_verbose(args);
				}
				inline Array get_stack() { return Array(); } // Stub
				inline void print_stack() { return; }        // Stub
			)")
							.dedent());
			file->close();
		} else {
			ERR_PRINT("Failed to open file: gdscript.h");
		}
	}
}

void GDScriptCPPGen::generate(const Vector<String> &p_file_path) {
	ERR_FAIL_COND_MSG(p_file_path.is_empty(), "No files provided for GDScriptCPPGen.");
	setup_output_folder();
	for (int i = 0; i < p_file_path.size(); ++i) {
		add_file_to_queue(p_file_path[i]);
	}
	while (!file_queue.is_empty()) {
		String file_path = file_queue.pop_front();
		Error error;
		Ref<GDScriptParserRef> gdscript_parser_ref = GDScriptCache::get_parser(file_path, GDScriptParserRef::Status::FULLY_SOLVED, error, String());
		if (error != OK) {
			ERR_PRINT("Failed to get GDScript parser and analyze for file: " + file_path);
			print_line("Failed to get GDScript parser and analyze for file: " + file_path);
			continue;
		}
		GDScriptParser *parser = gdscript_parser_ref->get_parser();

		if (parser->get_tree()->type != GDScriptParser::Node::Type::CLASS) {
			ERR_PRINT("The root node is not a class in file: " + file_path + ". Only scripts with a class at the root are supported.");
			print_line("Failed to get GDScript parser and analyze for file: " + file_path);
			continue;
		}

		current = memnew(GeneratingClass);
		current->file_path = file_path;
		current->root_class = parser->get_tree();
		current->class_name = get_class_name(current->root_class);
		current->output_file_name = get_output_file_name(current->root_class);

		if (!is_class_valid()) {
			ERR_PRINT("The class is not valid in file: " + file_path);
			print_line("Failed to validate class in file: " + file_path);
			memdelete(current);
			current = nullptr;
			continue;
		}
		gen_cpp_class();
		gen_header_class(); // after cpp for the preloads to be set
		write_header_file();
		write_cpp_file();

		GeneratedClass *generated_class = memnew(GeneratedClass);
		generated_class->class_name = current->class_name;
		generated_class->file_path = current->file_path;
		generated_class->output_file_name = current->output_file_name;
		generated_class->is_abstract = current->root_class->is_abstract;
		generated_classes.push_back(generated_class);

		print_line("Generated C++ class: " + current->class_name + " from GDScript file: " + file_path);
		print_line("Output path: " + current->output_file_name);
		print_line("Source code header:\n" + current->source_code_header);
		print_line("Source code cpp:\n" + current->source_code_cpp);

		if (current != nullptr) {
			memdelete(current);
			current = nullptr;
		}
	}
	write_register_file();
}

void GDScriptCPPGen::clear() {
	class_name_cache.clear();
	taken_class_names.clear();

	if (current != nullptr) {
		memdelete(current);
		current = nullptr;
	}

	for (int i = 0; i < generated_classes.size(); ++i) {
		if (generated_classes[i] != nullptr) {
			memdelete(generated_classes[i]);
		}
	}
	generated_classes.clear();
}

String GDScriptCPPGen::get_class_name(const GDScriptParser::ClassNode *p_class) {
	if (class_name_cache.has(p_class->fqcn)) {
		return class_name_cache[p_class->fqcn];
	}
	String class_name = String(p_class->identifier != nullptr ? p_class->identifier->name : StringName()).to_pascal_case();
	while (class_name.is_empty() || taken_class_names.has(class_name)) {
		class_name = "UnnamedClass";
		if (unnamed_class_counter > 0) {
			class_name += "_" + String::num(unnamed_class_counter) + "_";
		}
		unnamed_class_counter++;
	}
	class_name += "Gen";
	class_name_cache[p_class->fqcn] = class_name;
	taken_class_names.push_back(class_name);
	return class_name;
}

String GDScriptCPPGen::to_snake_case_no_number_split(const String &p_name) {
	String result;
	String snake_str = p_name.to_snake_case();
	for (int i = 0; i < snake_str.length(); i++) {
		char32_t c = snake_str[i];
		if (c == U'_' && i + 1 < snake_str.length() && is_digit(snake_str[i + 1])) {
			continue;
		}
		result += c;
	}
	return result;
}

String GDScriptCPPGen::get_output_file_name(const GDScriptParser::ClassNode *p_class) {
	return to_snake_case_no_number_split(get_class_name(p_class));
}

String GDScriptCPPGen::get_include(const GDScriptParser::DataType p_datatype) {
	if (p_datatype != GDScriptParser::DataType()) {
		return "";
	}
	switch (p_datatype.kind) {
		case GDScriptParser::DataType::NATIVE:
			return "<godot_cpp/classes/" + to_snake_case_no_number_split(String(p_datatype.native_type)) + ".hpp>";
		case GDScriptParser::DataType::SCRIPT:
			return "<godot_cpp/classes/script.hpp>";
		case GDScriptParser::DataType::CLASS:
			if (p_datatype.class_type->outer != nullptr) {
				// Inner class are contained in its parents class file.
				GDScriptParser::ClassNode *outer_class = p_datatype.class_type->outer;
				GDScriptParser::ClassNode *outer_most_class = outer_class;
				while (outer_class != nullptr) {
					outer_class = outer_class->outer;
					if (outer_class != nullptr) {
						outer_most_class = outer_class;
					}
				}
				return get_output_file_name(outer_most_class) + ".h";
			}
			return "\"" + get_output_file_name(p_datatype.class_type) + ".h\"";
		case GDScriptParser::DataType::VARIANT:
			return "<godot_cpp/variant/variant.hpp>";
		case GDScriptParser::DataType::BUILTIN:
			switch (p_datatype.builtin_type) {
				case Variant::NIL:
				case Variant::BOOL:
				case Variant::INT:
				case Variant::FLOAT:
					return "";
				case Variant::OBJECT:
					return "<godot_cpp/classes/object.hpp>";
				default:
					break;
			}
			if (p_datatype.builtin_type == Variant::ARRAY && p_datatype.has_container_element_type(0)) {
				return "<godot_cpp/variant/typed_array.hpp>";
			}
			if (p_datatype.builtin_type == Variant::DICTIONARY && p_datatype.has_container_element_types()) {
				return "<godot_cpp/variant/typed_dictionary.hpp>";
			}
			return "<godot_cpp/variant/" + to_snake_case_no_number_split(Variant::get_type_name(p_datatype.builtin_type)) + ".hpp>";
		default:
			break;
	}
	return "";
}

String GDScriptCPPGen::get_datatype_name(const GDScriptParser::DataType p_datatype) {
	if (p_datatype != GDScriptParser::DataType()) {
		return "";
	}
	switch (p_datatype.kind) {
		case GDScriptParser::DataType::NATIVE:
			return String(p_datatype.native_type);
		case GDScriptParser::DataType::CLASS:
			return get_class_name(p_datatype.class_type);
		case GDScriptParser::DataType::SCRIPT:
			return "Script";
		case GDScriptParser::DataType::VARIANT:
			return "Variant";
		case GDScriptParser::DataType::BUILTIN:
			if (p_datatype.builtin_type == Variant::NIL) {
				return "Variant";
			}
			if (p_datatype.builtin_type == Variant::ARRAY && p_datatype.has_container_element_type(0)) {
				return vformat("TypedArray<%s>", get_datatype_name(p_datatype.get_container_element_type(0)));
			}
			if (p_datatype.builtin_type == Variant::DICTIONARY && p_datatype.has_container_element_types()) {
				return vformat("TypedDictionary<%s, %s>", get_datatype_name(p_datatype.get_container_element_type_or_variant(0)), get_datatype_name(p_datatype.get_container_element_type_or_variant(1)));
			}
			return Variant::get_type_name(p_datatype.builtin_type);
		case GDScriptParser::DataType::ENUM:
			return "int";
		default:
			break;
	}
	return p_datatype.to_string_strict();
}

void GDScriptCPPGen::write_header_file() {
	ERR_FAIL_COND_MSG(current == nullptr, "Current is null.");
	String header_file_path = output_folder.path_join("gen").path_join(current->output_file_name + ".h");
	Ref<FileAccess> file = FileAccess::open(header_file_path, FileAccess::WRITE);
	if (file.is_valid()) {
		file->store_string("// This file is generated by GDScriptCPPGen.\n");
		file->store_string("// Generated based on GDScript file: " + current->file_path + "\n\n");
		file->store_string("#pragma once\n\n");
		file->store_string("#include <godot_cpp/variant/utility_functions.hpp>\n");
		file->store_string("#include \"gdscript.h\"\n");
		for (const Variant &include : current->includes_header) {
			file->store_string("#include " + String(include) + "\n");
		}
		file->store_string("using namespace godot;\n\n");
		file->store_string("\n" + current->source_code_header + "\n");
		file->close();
	} else {
		ERR_PRINT("Failed to open file: " + header_file_path);
	}
}

void GDScriptCPPGen::write_cpp_file() {
	ERR_FAIL_COND_MSG(current == nullptr, "Current is null.");
	String cpp_file_path = output_folder.path_join("gen").path_join(current->output_file_name + ".cpp");
	Ref<FileAccess> file = FileAccess::open(cpp_file_path, FileAccess::WRITE);
	if (file.is_valid()) {
		file->store_string("// This file is generated by GDScriptCPPGen.\n");
		file->store_string("// Generated based on GDScript file: " + current->file_path + "\n\n");
		file->store_string("#include \"" + current->output_file_name + ".h\"\n");
		for (const Variant &include : current->includes_cpp) {
			file->store_string("#include " + String(include) + "\n");
		}
		file->store_string("\n" + current->source_code_cpp + "\n");
		file->close();
	} else {
		ERR_PRINT("Failed to open file: " + cpp_file_path);
	}
}

void GDScriptCPPGen::write_register_file() {
	String header_file_path = output_folder.path_join("gen").path_join("register_types.h");
	Ref<FileAccess> file = FileAccess::open(header_file_path, FileAccess::WRITE);
	if (file.is_valid()) {
		file->store_string("// This file is generated by GDScriptCPPGen.\n");
		file->store_string("#pragma once\n\n");
		file->store_string("#include <godot_cpp/core/class_db.hpp>\n");
		file->store_string("using namespace godot;\n\n");
		file->store_string("void initialize_gdscript_cpp_module(ModuleInitializationLevel p_level);\n");
		file->store_string("void uninitialize_gdscript_cpp_module(ModuleInitializationLevel p_level);\n");
		file->close();
	} else {
		ERR_PRINT("Failed to open file: " + header_file_path);
	}

	String cpp_file_path = output_folder.path_join("gen").path_join("register_types.cpp");
	file = FileAccess::open(cpp_file_path, FileAccess::WRITE);
	if (file.is_valid()) {
		file->store_string("// This file is generated by GDScriptCPPGen.\n");
		file->store_string("#include \"register_types.h\"\n\n");
		file->store_string("#include <gdextension_interface.h>\n");
		file->store_string("#include <godot_cpp/core/defs.hpp>\n");
		file->store_string("#include <godot_cpp/godot.hpp>\n\n");
		for (const GeneratedClass *generated_class : generated_classes) {
			file->store_string("#include \"" + generated_class->output_file_name + ".h\"\n");
		}
		file->store_string("\nusing namespace godot;\n");
		file->store_string("void initialize_gdscript_cpp_module(ModuleInitializationLevel p_level) {\n");
		file->store_string("\tif (p_level != MODULE_INITIALIZATION_LEVEL_SCENE) { return; }\n\n");
		for (const GeneratedClass *generated_class : generated_classes) {
			if (generated_class->is_abstract) {
				file->store_string("\tGDREGISTER_ABSTRACT_CLASS(" + generated_class->class_name + ");\n");
			} else {
				file->store_string("\tGDREGISTER_RUNTIME_CLASS(" + generated_class->class_name + ");\n");
			}
		}
		file->store_string("}\n");
		file->store_string("void uninitialize_gdscript_cpp_module(ModuleInitializationLevel p_level) {\n\t if (p_level != MODULE_INITIALIZATION_LEVEL_SCENE) { return; }\n");
		file->store_string("}\n");
		file->store_string(String(R"(
		extern "C" {
		// Initialization.
		GDExtensionBool GDE_EXPORT gdscript_cpp_init(GDExtensionInterfaceGetProcAddress p_get_proc_address, const GDExtensionClassLibraryPtr p_library, GDExtensionInitialization *r_initialization) {
			godot::GDExtensionBinding::InitObject init_obj(p_get_proc_address, p_library, r_initialization);

			init_obj.register_initializer(initialize_gdscript_cpp_module);
			init_obj.register_terminator(uninitialize_gdscript_cpp_module);
			init_obj.set_minimum_library_initialization_level(MODULE_INITIALIZATION_LEVEL_SCENE);

			return init_obj.init();
		}
		}
		)")
						.dedent());
		file->close();
	} else {
		ERR_PRINT("Failed to open file: " + cpp_file_path);
	}
}

bool GDScriptCPPGen::is_class_valid() {
	if (current == nullptr) {
		ERR_PRINT("Current is null.");
		return false;
	}
	for (const GDScriptParser::ClassNode::Member &member : current->root_class->members) {
		switch (member.type) {
			case GDScriptParser::ClassNode::Member::FUNCTION:
				if (member.function->is_coroutine) {
					return false;
				}
				break;
			default:
				break;
		}
	}
	return true;
}

void GDScriptCPPGen::gen_header_class() {
	ERR_FAIL_COND_MSG(current == nullptr, "Current is null.");
	String base_class_name;
	if (current->root_class->base_type != GDScriptParser::DataType()) {
		GDScriptParser::ClassNode *base_class = current->root_class->base_type.class_type;
		current->push_include_header(get_output_file_name(base_class) + ".h");
		base_class_name = get_class_name(base_class);
	} else {
		GDScriptParser::DataType base_native_class;
		base_native_class.native_type = current->root_class->get_datatype().native_type;
		base_native_class.kind = GDScriptParser::DataType::NATIVE;
		current->push_include_header(get_include(base_native_class));
		base_class_name = get_datatype_name(base_native_class);
	}

	String class_signature = "class " + get_class_name(current->root_class);
	if (!base_class_name.is_empty()) {
		class_signature += " : public " + base_class_name;
	}
	class_signature += " {";
	current->push_line_header(class_signature);
	current->increment_indent_level_header();
	if (!base_class_name.is_empty()) {
		current->push_line_header("GDCLASS(" + get_class_name(current->root_class) + ", " + base_class_name + ");");
	}
	current->decrement_indent_level_header();
	current->push_line_header("protected:");
	current->increment_indent_level_header();
	current->push_line_header("static void _bind_methods();");
	current->decrement_indent_level_header();
	current->push_line_header("public:");
	current->increment_indent_level_header();

	String unnamed_enum_body;
	for (const GDScriptParser::ClassNode::Member &member : current->root_class->members) {
		switch (member.type) {
			case GDScriptParser::ClassNode::Member::CLASS: {
				GDScriptParser::ClassNode *previous_class = current->root_class;
				current->root_class = member.m_class;
				gen_header_class();
				current->root_class = previous_class;
			} break;
			case GDScriptParser::ClassNode::Member::FUNCTION: {
				String function_signature = member.function->is_abstract ? "virtual " : "";
				function_signature += member.function->is_static ? "static " : "";

				if (member.function->return_type != nullptr) {
					current->push_include_header(get_include(member.get_datatype()));
					function_signature += get_datatype_name(member.get_datatype()) + " ";
				} else {
					function_signature += "void ";
				}
				function_signature += member.get_name() + "(";
				for (int i = 0; i < member.function->parameters.size(); ++i) {
					const GDScriptParser::ParameterNode *param = member.function->parameters[i];
					current->push_include_header(get_include(param->datatype));
					function_signature += get_datatype_name(param->datatype) + " " + param->identifier->name;
					if (i < member.function->parameters.size() - 1) {
						function_signature += ", ";
					}
				}
				function_signature += member.function->is_abstract ? ") = 0" : ")";

				bool is_function_override = false;
				if (current->root_class->base_type != GDScriptParser::DataType()) {
					GDScriptParser::ClassNode *base_class = current->root_class->base_type.class_type;
					is_function_override = base_class->has_function(member.get_name());
				} else {
					is_function_override = ClassDB::has_method(base_class_name, member.get_name());
				}
				if (is_function_override) {
					function_signature += " override";
				}
				function_signature += ";";
				current->push_line_header(function_signature);
			} break;
			case GDScriptParser::ClassNode::Member::CONSTANT:
				gen_constant(member.constant);
				current->flush_buffer_to_header();
				break;
			case GDScriptParser::ClassNode::Member::VARIABLE:
				gen_variable(member.variable);
				current->flush_buffer_to_header();
				break;
			case GDScriptParser::ClassNode::Member::ENUM: {
				current->push_line_header("enum " + member.get_name() + " {");
				current->increment_indent_level_header();
				for (const GDScriptParser::EnumNode::Value &E : member.m_enum->values) {
					current->push_line_header(String(E.identifier->name) + " = " + String::num_int64(E.value) + ",");
				}
				current->decrement_indent_level_header();
				current->push_line_header("};");
			} break;
			case GDScriptParser::ClassNode::Member::ENUM_VALUE:
				unnamed_enum_body += String(member.enum_value.identifier->name) + " = " + String::num_int64(member.enum_value.value) + ",\n";
				break;
			default:
				break;
		}
	}
	if (!unnamed_enum_body.is_empty()) {
		current->push_line_header("enum { " + unnamed_enum_body + " };", "");
	}

	for (int i = 0; i < current->preload_cache.size(); i++) {
		if (i == 0) {
			current->push_line_header("Array preload;");
			current->push_line_header(get_class_name(current->root_class) + "() {");
		}

		current->push_line_header("preload.append(ResourceLoader::get_singleton()->load(\"" + String(current->preload_cache[i]) + "\"));");

		if (i == current->preload_cache.size() - 1) {
			current->push_line_header("}\n");
		}
	}

	current->decrement_indent_level_header();
	current->push_line_header("};");
}

void GDScriptCPPGen::gen_cpp_class() {
	current->push_line_cpp("// Class: " + current->class_name);
	for (const GDScriptParser::ClassNode::Member &member : current->root_class->members) {
		switch (member.type) {
			case GDScriptParser::ClassNode::Member::FUNCTION: {
				if (member.function->is_abstract) {
					continue; // No need to generate code for abstract functions
				}
				String function_signature;
				if (member.function->return_type != nullptr) {
					function_signature = get_datatype_name(member.get_datatype()) + " ";
				} else {
					function_signature = "void ";
				}
				function_signature += get_class_name(current->root_class) + "::" + member.get_name() + "(";
				if (member.function->parameters.size() > 0) {
					for (int i = 0; i < member.function->parameters.size(); ++i) {
						const GDScriptParser::ParameterNode *param = member.function->parameters[i];
						function_signature += get_datatype_name(param->datatype) + " " + param->identifier->name;
						if (i < member.function->parameters.size() - 1) {
							function_signature += ", ";
						}
					}
				}
				function_signature += ") {";
				current->push_line_cpp(function_signature);
				current->increment_indent_level_cpp();
				gen_suite(member.function->body);
				current->flush_buffer_to_cpp();
				current->decrement_indent_level_cpp();
				current->push_line_cpp("}");
			} break;
			case GDScriptParser::ClassNode::Member::CLASS: {
				GDScriptParser::ClassNode *previous_class = current->root_class;
				current->root_class = member.m_class;
				gen_cpp_class();
				current->root_class = previous_class;
			} break;
			default:
				break;
		}
	}

	current->push_line_cpp("void " + get_class_name(current->root_class) + "::_bind_methods() {");
	current->increment_indent_level_cpp();

	for (const GDScriptParser::ClassNode::Member &member : current->root_class->members) {
		// Broken: need verification if works correctly
		switch (member.type) {
			case GDScriptParser::ClassNode::Member::FUNCTION: {
				String bind_text;
				bind_text = "ClassDB::bind_method(D_METHOD(\"" + member.get_name() + "\"";
				for (const GDScriptParser::ParameterNode *param : member.function->parameters) {
					bind_text += ", \"" + param->identifier->name + "\"";
				}
				bind_text += "), &";
				bind_text += get_class_name(current->root_class) + "::" + member.get_name() + ");";
				current->push_line_cpp(bind_text);
			} break;
			case GDScriptParser::ClassNode::Member::VARIABLE: {
				String cname = get_class_name(current->root_class);
				String prop = member.get_name();

				String setter = "set_" + prop;
				String getter = "get_" + prop;

				// PropertyInfo needs the type of the property. For a variable, the type is stored in the member.
				String property_info_type = "Variant::" + member.variable->get_datatype().to_string_strict();
				if (member.variable->get_datatype().class_type != nullptr || member.variable->get_datatype().native_type.is_empty()) {
					property_info_type = "Variant::OBJECT";
				}

				String bind_text = "ADD_PROPERTY(PropertyInfo(" + property_info_type + ", \"" + prop + "\"), \"" + setter + "\", \"" + getter + "\");";
				current->push_line_cpp(bind_text);
			} break;
			case GDScriptParser::ClassNode::Member::CONSTANT: {
				String bind_text = "BIND_CONSTANT(" + member.get_name() + ");";
				current->push_line_cpp(bind_text);
			} break;
			case GDScriptParser::ClassNode::Member::ENUM: {
				for (const auto &value : member.m_enum->values) {
					String bind_text = "BIND_ENUM_CONSTANT(" + member.get_name() + "::" + String(value.identifier->name) + ");";
					current->push_line_cpp(bind_text);
				}
			} break;
			case GDScriptParser::ClassNode::Member::SIGNAL: {
				String bind_text = "ADD_SIGNAL(MethodInfo(\"" + member.get_name() + "\"";
				for (int i = 0; i < member.signal->parameters.size(); ++i) {
					if (i == 0) {
						bind_text += ", ";
					}
					const GDScriptParser::ParameterNode *param = member.signal->parameters[i];
					String param_type = "Variant::" + param->get_datatype().to_string_strict();
					if (param->get_datatype().class_type != nullptr || param->get_datatype().native_type.is_empty()) {
						param_type = "Variant::OBJECT";
					}

					bind_text += "PropertyInfo(" + param_type + ", \"" + param->identifier->name + "\")";
					if (i < member.signal->parameters.size() - 1) {
						bind_text += ", ";
					}
				}
				bind_text += "));";
				current->push_line_cpp(bind_text);
			} break;
			case GDScriptParser::ClassNode::Member::ENUM_VALUE: {
				String bind_text = "BIND_ENUM_CONSTANT(" + String(member.enum_value.identifier->name) + ");";
				current->push_line_cpp(bind_text);
			} break;
			default:
				break;
		}
	}

	current->decrement_indent_level_cpp();
	current->push_line_cpp("}");
}

void GDScriptCPPGen::gen_array(const GDScriptParser::ArrayNode *p_array) {
	current->push_include_buffer("<godot_cpp/variant/array.hpp>");
	current->push_buffer("Array { ");
	for (int i = 0; i < p_array->elements.size(); i++) {
		if (i > 0) {
			current->push_buffer(", ");
		}
		gen_expression(p_array->elements[i]);
	}
	current->push_buffer(" }\n");
}

void GDScriptCPPGen::gen_assignment(const GDScriptParser::AssignmentNode *p_assignment) {
	// Broken: some most native properties can only be accessed by setters and getters in godot-cpp, not directly like gdscript
	switch (p_assignment->assignee->type) {
		case GDScriptParser::Node::IDENTIFIER:
			gen_identifier(static_cast<const GDScriptParser::IdentifierNode *>(p_assignment->assignee));
			break;
		case GDScriptParser::Node::SUBSCRIPT:
			gen_subscript(static_cast<const GDScriptParser::SubscriptNode *>(p_assignment->assignee));
			break;
		default:
			break; // Unreachable.
	}

	switch (p_assignment->operation) {
		case GDScriptParser::AssignmentNode::OP_ADDITION:
			current->push_buffer(" +");
			break;
		case GDScriptParser::AssignmentNode::OP_SUBTRACTION:
			current->push_buffer(" -");
			break;
		case GDScriptParser::AssignmentNode::OP_MULTIPLICATION:
			current->push_buffer(" *");
			break;
		case GDScriptParser::AssignmentNode::OP_DIVISION:
			current->push_buffer(" /");
			break;
		case GDScriptParser::AssignmentNode::OP_MODULO:
			current->push_buffer(" %");
			break;
		case GDScriptParser::AssignmentNode::OP_POWER:
			current->push_buffer(" **");
			break;
		case GDScriptParser::AssignmentNode::OP_BIT_SHIFT_LEFT:
			current->push_buffer(" <<");
			break;
		case GDScriptParser::AssignmentNode::OP_BIT_SHIFT_RIGHT:
			current->push_buffer(" >>");
			break;
		case GDScriptParser::AssignmentNode::OP_BIT_AND:
			current->push_buffer(" &");
			break;
		case GDScriptParser::AssignmentNode::OP_BIT_OR:
			current->push_buffer(" |");
			break;
		case GDScriptParser::AssignmentNode::OP_BIT_XOR:
			current->push_buffer(" ^");
			break;
		case GDScriptParser::AssignmentNode::OP_NONE:
			current->push_buffer(" ");
			break;
	}
	current->push_buffer("= ");
	gen_expression(p_assignment->assigned_value);
	current->end_line_buffer();
}

void GDScriptCPPGen::gen_await(const GDScriptParser::AwaitNode *p_await) {
	current->push_include_buffer(get_include(p_await->get_datatype()));
	// TODO: exclusion system
}

void GDScriptCPPGen::gen_binary_op(const GDScriptParser::BinaryOpNode *p_binary_op) {
	current->push_include_buffer(get_include(p_binary_op->left_operand->get_datatype()));
	current->push_include_buffer(get_include(p_binary_op->right_operand->get_datatype()));
	current->push_buffer("(");
	gen_expression(p_binary_op->left_operand);
	switch (p_binary_op->operation) {
		case GDScriptParser::BinaryOpNode::OP_ADDITION:
			current->push_buffer(" + ");
			break;
		case GDScriptParser::BinaryOpNode::OP_SUBTRACTION:
			current->push_buffer(" - ");
			break;
		case GDScriptParser::BinaryOpNode::OP_MULTIPLICATION:
			current->push_buffer(" * ");
			break;
		case GDScriptParser::BinaryOpNode::OP_DIVISION:
			current->push_buffer(" / ");
			break;
		case GDScriptParser::BinaryOpNode::OP_MODULO:
			current->push_buffer(" % ");
			break;
		case GDScriptParser::BinaryOpNode::OP_POWER:
			current->push_buffer(" ** ");
			break;
		case GDScriptParser::BinaryOpNode::OP_BIT_LEFT_SHIFT:
			current->push_buffer(" << ");
			break;
		case GDScriptParser::BinaryOpNode::OP_BIT_RIGHT_SHIFT:
			current->push_buffer(" >> ");
			break;
		case GDScriptParser::BinaryOpNode::OP_BIT_AND:
			current->push_buffer(" & ");
			break;
		case GDScriptParser::BinaryOpNode::OP_BIT_OR:
			current->push_buffer(" | ");
			break;
		case GDScriptParser::BinaryOpNode::OP_BIT_XOR:
			current->push_buffer(" ^ ");
			break;
		case GDScriptParser::BinaryOpNode::OP_LOGIC_AND:
			current->push_buffer(" && ");
			break;
		case GDScriptParser::BinaryOpNode::OP_LOGIC_OR:
			current->push_buffer(" || ");
			break;
		case GDScriptParser::BinaryOpNode::OP_CONTENT_TEST:
			// TODO: make it work
			current->push_buffer(" IN ");
			break;
		case GDScriptParser::BinaryOpNode::OP_COMP_EQUAL:
			current->push_buffer(" == ");
			break;
		case GDScriptParser::BinaryOpNode::OP_COMP_NOT_EQUAL:
			current->push_buffer(" != ");
			break;
		case GDScriptParser::BinaryOpNode::OP_COMP_LESS:
			current->push_buffer(" < ");
			break;
		case GDScriptParser::BinaryOpNode::OP_COMP_LESS_EQUAL:
			current->push_buffer(" <= ");
			break;
		case GDScriptParser::BinaryOpNode::OP_COMP_GREATER:
			current->push_buffer(" > ");
			break;
		case GDScriptParser::BinaryOpNode::OP_COMP_GREATER_EQUAL:
			current->push_buffer(" >= ");
			break;
	}
	gen_expression(p_binary_op->right_operand);
	current->push_buffer(")");
}

void GDScriptCPPGen::gen_call(const GDScriptParser::CallNode *p_call) {
	// Broken: global scope function (print) not yet being found despite #include
	current->push_include_buffer(get_include(p_call->get_datatype()));
	if (p_call->is_super) {
		String base_class_name;
		if (current->root_class->base_type != GDScriptParser::DataType()) {
			GDScriptParser::ClassNode *base_class = current->root_class->base_type.class_type;
			current->push_include_header(get_output_file_name(base_class) + ".h");
			base_class_name = get_class_name(base_class);
		} else {
			GDScriptParser::DataType base_native_class;
			base_native_class.native_type = current->root_class->get_datatype().native_type;
			base_native_class.kind = GDScriptParser::DataType::NATIVE;
			current->push_include_header(get_include(base_native_class));
			base_class_name = get_datatype_name(base_native_class);
		}
		current->push_buffer(base_class_name);

		current->push_buffer("::");
		if (p_call->callee != nullptr) {
			gen_expression(p_call->callee);
		} else {
			current->push_buffer(p_call->function_name);
		}
	} else {
		gen_expression(p_call->callee);
		if (current->source_code_buffer.ends_with("char")) {
			current->source_code_buffer = current->source_code_buffer.erase(current->source_code_buffer.size() - 3);
		}
	}
	current->push_buffer("(");
	for (int i = 0; i < p_call->arguments.size(); i++) {
		if (i > 0) {
			current->push_buffer(" , ");
		}
		gen_expression(p_call->arguments[i]);
	}
	current->push_buffer(")");
}

void GDScriptCPPGen::gen_cast(const GDScriptParser::CastNode *p_cast) {
	current->push_include_buffer("<godot_cpp/classes/object.hpp>");
	current->push_buffer("Object::cast_to<");
	gen_type(p_cast->cast_type);
	current->push_buffer(">(");
	gen_expression(p_cast->operand);
	current->push_buffer(")");
}

void GDScriptCPPGen::gen_constant(const GDScriptParser::ConstantNode *p_constant) {
	current->push_include_buffer(get_include(p_constant->get_datatype()));
	current->push_buffer("const " + get_datatype_name(p_constant->get_datatype()) + " ");
	gen_identifier(p_constant->identifier);
	current->push_buffer(" = ");
	if (get_datatype_name(p_constant->get_datatype()).begins_with("TypedDictionary")) {
		current->push_buffer(get_datatype_name(p_constant->get_datatype()) + "(");
	}
	gen_expression(p_constant->initializer);
	if (get_datatype_name(p_constant->get_datatype()).begins_with("TypedDictionary")) {
		current->push_buffer(")");
	}
	current->end_line_buffer();
}

void GDScriptCPPGen::gen_dictionary(const GDScriptParser::DictionaryNode *p_dictionary) {
	current->push_include_buffer("<godot_cpp/variant/dictionary.hpp>");
	current->push_buffer("make_dict(");
	current->push_buffer("{\n");
	current->increment_indent_level_buffer();
	for (int i = 0; i < p_dictionary->elements.size(); i++) {
		current->push_buffer("{");
		gen_expression(p_dictionary->elements[i].key);
		current->push_buffer(", ");
		gen_expression(p_dictionary->elements[i].value);
		current->push_buffer("}\n");
		if (i + 1 < p_dictionary->elements.size()) {
			current->push_buffer(",\n");
		}
	}
	current->decrement_indent_level_buffer();
	current->push_buffer("}\n");
	current->push_buffer(")");
}

void GDScriptCPPGen::gen_expression(const GDScriptParser::ExpressionNode *p_expression) {
	current->push_include_buffer(get_include(p_expression->get_datatype()));
	switch (p_expression->type) {
		case GDScriptParser::Node::ARRAY:
			gen_array(static_cast<const GDScriptParser::ArrayNode *>(p_expression));
			break;
		case GDScriptParser::Node::ASSIGNMENT:
			gen_assignment(static_cast<const GDScriptParser::AssignmentNode *>(p_expression));
			break;
		case GDScriptParser::Node::AWAIT:
			gen_await(static_cast<const GDScriptParser::AwaitNode *>(p_expression));
			break;
		case GDScriptParser::Node::BINARY_OPERATOR:
			gen_binary_op(static_cast<const GDScriptParser::BinaryOpNode *>(p_expression));
			break;
		case GDScriptParser::Node::CALL:
			gen_call(static_cast<const GDScriptParser::CallNode *>(p_expression));
			break;
		case GDScriptParser::Node::CAST:
			gen_cast(static_cast<const GDScriptParser::CastNode *>(p_expression));
			break;
		case GDScriptParser::Node::DICTIONARY:
			gen_dictionary(static_cast<const GDScriptParser::DictionaryNode *>(p_expression));
			break;
		case GDScriptParser::Node::GET_NODE:
			gen_get_node(static_cast<const GDScriptParser::GetNodeNode *>(p_expression));
			break;
		case GDScriptParser::Node::IDENTIFIER:
			gen_identifier(static_cast<const GDScriptParser::IdentifierNode *>(p_expression));
			break;
		case GDScriptParser::Node::LAMBDA:
			gen_lambda(static_cast<const GDScriptParser::LambdaNode *>(p_expression));
			break;
		case GDScriptParser::Node::LITERAL:
			gen_literal(static_cast<const GDScriptParser::LiteralNode *>(p_expression));
			break;
		case GDScriptParser::Node::PRELOAD:
			gen_preload(static_cast<const GDScriptParser::PreloadNode *>(p_expression));
			break;
		case GDScriptParser::Node::SELF:
			gen_self(static_cast<const GDScriptParser::SelfNode *>(p_expression));
			break;
		case GDScriptParser::Node::SUBSCRIPT:
			gen_subscript(static_cast<const GDScriptParser::SubscriptNode *>(p_expression));
			break;
		case GDScriptParser::Node::TERNARY_OPERATOR:
			gen_ternary_op(static_cast<const GDScriptParser::TernaryOpNode *>(p_expression));
			break;
		case GDScriptParser::Node::TYPE_TEST:
			gen_type_test(static_cast<const GDScriptParser::TypeTestNode *>(p_expression));
			break;
		case GDScriptParser::Node::UNARY_OPERATOR:
			gen_unary_op(static_cast<const GDScriptParser::UnaryOpNode *>(p_expression));
			break;
		default:
			break;
	}
}

void GDScriptCPPGen::gen_for(const GDScriptParser::ForNode *p_for) {
	current->push_include_buffer(get_include(p_for->list->get_datatype()));
	current->push_buffer("for (auto ");
	gen_identifier(p_for->variable);
	current->push_buffer(" : ");
	gen_expression(p_for->list);
	current->push_buffer(") {\n");
	current->increment_indent_level_buffer();
	gen_suite(p_for->loop);
	current->decrement_indent_level_buffer();
	current->push_buffer("}\n");
}

void GDScriptCPPGen::gen_get_node(const GDScriptParser::GetNodeNode *p_get_node) {
	current->push_buffer("get_node(\"" + p_get_node->full_path + "\")");
}

void GDScriptCPPGen::gen_if(const GDScriptParser::IfNode *p_if, bool p_is_elif) {
	if (p_is_elif) {
		current->push_buffer("else if (");
	} else {
		current->push_buffer("if (");
	}
	gen_expression(p_if->condition);
	current->push_buffer(") {\n");

	current->increment_indent_level_buffer();
	gen_suite(p_if->true_block);
	current->decrement_indent_level_buffer();

	current->push_buffer("} ");

	if (p_if->false_block != nullptr) {
		if (p_if->false_block->statements.size() == 1 &&
				p_if->false_block->statements[0]->type == GDScriptParser::Node::IF) {
			gen_if(static_cast<const GDScriptParser::IfNode *>(p_if->false_block->statements[0]), true);
			return;
		}
		current->push_buffer("else {");
		current->increment_indent_level_buffer();
		gen_suite(p_if->false_block);
		current->decrement_indent_level_buffer();
		current->push_buffer("}\n");
	}
}

void GDScriptCPPGen::gen_identifier(const GDScriptParser::IdentifierNode *p_identifier) {
	if (p_identifier != nullptr) {
		current->push_buffer(p_identifier->name);
	}
}

void GDScriptCPPGen::gen_lambda(const GDScriptParser::LambdaNode *p_lambda) {
	// Broken: callable does not have a cpp lambda constructor
	current->push_include_buffer("<godot_cpp/variant/callable.hpp>");
	current->push_buffer("Callable([this, &](");
	for (int i = 0; i < p_lambda->function->parameters.size(); ++i) {
		const GDScriptParser::ParameterNode *param = p_lambda->function->parameters[i];
		current->push_buffer(get_datatype_name(param->datatype) + " " + param->identifier->name);
		if (i < p_lambda->function->parameters.size() - 1) {
			current->push_buffer(", ");
		}
	}
	current->push_buffer(") {\n");
	current->increment_indent_level_buffer();
	gen_suite(p_lambda->function->body);
	current->decrement_indent_level_buffer();
	current->push_buffer("}\n");
}

void GDScriptCPPGen::gen_literal(const GDScriptParser::LiteralNode *p_literal) {
	switch (p_literal->value.get_type()) {
		case Variant::NODE_PATH:
			current->push_include_buffer("<godot_cpp/variant\node_path.hpp>");
			current->push_buffer("NodePath(\"");
			break;
		case Variant::STRING:
			current->push_include_buffer("<godot_cpp/variant/string.hpp>");
			current->push_buffer("\"");
			break;
		case Variant::STRING_NAME:
			current->push_include_buffer("<godot_cpp/variant/string_name.hpp>");
			current->push_buffer("StringName(\"");
			break;
		default:
			break;
	}
	current->push_buffer(p_literal->value);
	switch (p_literal->value.get_type()) {
		case Variant::STRING:
			current->push_buffer("\"");
			break;
		case Variant::STRING_NAME:
		case Variant::NODE_PATH:
			current->push_buffer("\")");
			break;
		default:
			break;
	}
}

void GDScriptCPPGen::gen_match(const GDScriptParser::MatchNode *p_match) {
	for (int i = 0; i < p_match->branches.size(); ++i) {
		const GDScriptParser::MatchBranchNode *branch = p_match->branches[i];
		if (i > 0) {
			current->push_buffer("else if (");
		} else {
			current->push_buffer("if (");
		}

		for (int j = 0; j < branch->patterns.size(); ++j) {
			const GDScriptParser::PatternNode *pattern = branch->patterns[j];
			switch (pattern->pattern_type) {
				case GDScriptParser::PatternNode::PT_LITERAL:
					gen_expression(p_match->test);
					current->push_buffer(" == ");
					gen_literal(pattern->literal);
					break;
				case GDScriptParser::PatternNode::PT_WILDCARD:
				case GDScriptParser::PatternNode::PT_BIND:
					current->push_buffer("true");
					break;
				case GDScriptParser::PatternNode::PT_EXPRESSION:
					gen_expression(p_match->test);
					current->push_buffer(" == ");
					gen_expression(pattern->expression);
					break;
				case GDScriptParser::PatternNode::PT_ARRAY: {
					if (pattern->array.size() == 0) {
						current->push_buffer("(Array((Variant)");
						gen_expression(p_match->test);
						current->push_buffer("))");
						current->push_buffer(" == Array()");
						break;
					}

					bool exact_size = true;
					for (int k = 0; k < pattern->array.size(); k++) {
						switch (pattern->array[k]->pattern_type) {
							case GDScriptParser::PatternNode::PT_REST:
								exact_size = false;
								break;
							default:
								break;
						}
					}

					bool index_backwards = false;
					for (int k = 0; k < pattern->array.size(); k++) {
						current->push_buffer("(");
						if (k == 0) {
							current->push_buffer("(Array((Variant)");
							gen_expression(p_match->test);
							current->push_buffer("))");
							if (exact_size) {
								current->push_buffer(".size() == " + itos(pattern->array.size()));
							} else {
								current->push_buffer(".size() >= " + itos(pattern->array.size() - 1));
							}
							current->push_buffer(") && (");
						}
						int index = k;
						if (index_backwards) {
							index = pattern->array.size() - k + 1;
						}
						switch (pattern->array[k]->pattern_type) {
							case GDScriptParser::PatternNode::PT_REST:
								index_backwards = true;
								break;
							case GDScriptParser::PatternNode::PT_LITERAL:
								current->push_buffer("(Array((Variant)");
								gen_expression(p_match->test);
								current->push_buffer("))");
								current->push_buffer("[");
								if (index_backwards) {
									current->push_buffer("(Array((Variant)");
									gen_expression(p_match->test);
									current->push_buffer("))");
									current->push_buffer(".size() -");
								}
								current->push_buffer(itos(index));
								current->push_buffer("]");
								current->push_buffer(" == ");
								gen_literal(pattern->array[k]->literal);
								break;
							case GDScriptParser::PatternNode::PT_EXPRESSION:
								current->push_buffer("(Array((Variant)");
								gen_expression(p_match->test);
								current->push_buffer("))");
								current->push_buffer("[");
								if (index_backwards) {
									current->push_buffer("(Array((Variant)");
									gen_expression(p_match->test);
									current->push_buffer("))");
									current->push_buffer(".size() -");
								}
								current->push_buffer(itos(index));
								current->push_buffer("]");
								current->push_buffer(" == ");
								gen_expression(pattern->array[k]->expression);
								break;
							case GDScriptParser::PatternNode::PT_WILDCARD:
							default:
								break;
						}

						current->push_buffer(")");
						if (k < pattern->array.size() - 1) {
							current->push_buffer(" && ");
						}
					}
				} break;
				case GDScriptParser::PatternNode::PT_DICTIONARY: {
					if (pattern->dictionary.size() == 0) {
						gen_expression(p_match->test);
						current->push_buffer(" == Dictionary()");
						break;
					}

					bool exact_size = true;
					for (int k = 0; k < pattern->dictionary.size() && pattern->dictionary[k].value_pattern == nullptr; k++) {
						switch (pattern->dictionary[k].value_pattern->pattern_type) {
							case GDScriptParser::PatternNode::PT_REST:
								exact_size = false;
								break;
							default:
								break;
						}
					}

					for (int k = 0; k < pattern->dictionary.size(); k++) {
						if (k == 0) {
							gen_expression(p_match->test);
							if (exact_size) {
								current->push_buffer(".size() == " + itos(pattern->dictionary.size()));
							} else {
								current->push_buffer(".size() >= " + itos(pattern->dictionary.size() - 1));
							}
							current->push_buffer(") && (");
						}

						if (pattern->dictionary[k].key != nullptr) {
							// Key can be null for rest pattern.
							gen_expression(p_match->test);
							current->push_buffer(".has(");
							gen_expression(pattern->dictionary[k].key);
							current->push_buffer(")");
							if (pattern->dictionary[k].value_pattern != nullptr) {
								current->push_buffer(" && ");
							}
						}
						if (pattern->dictionary[k].value_pattern != nullptr) {
							switch (pattern->dictionary[k].value_pattern->pattern_type) {
								case GDScriptParser::PatternNode::PT_LITERAL:
									gen_expression(p_match->test);
									current->push_buffer("[");
									gen_expression(pattern->dictionary[k].key);
									current->push_buffer("] == ");
									gen_literal(pattern->dictionary[k].value_pattern->literal);
									break;
								case GDScriptParser::PatternNode::PT_EXPRESSION:
									gen_expression(p_match->test);
									current->push_buffer("[");
									gen_expression(pattern->dictionary[k].key);
									current->push_buffer("] == ");
									gen_expression(pattern->dictionary[k].value_pattern->expression);
									break;
								default:
									break;
							}
						}
						if (k < pattern->dictionary.size() - 1) {
							current->push_buffer(" && ");
						}
					}
					current->push_buffer(" }\n");
				} break;
				default:
					break;
			}

			if (j < branch->patterns.size() - 1) {
				current->push_buffer(" && ");
			}
		}

		current->push_buffer(") {\n");
		current->increment_indent_level_buffer();
		for (int j = 0; j < branch->patterns.size(); ++j) {
			const GDScriptParser::PatternNode *pattern = branch->patterns[j];
			switch (pattern->pattern_type) {
				case GDScriptParser::PatternNode::PT_BIND:
					current->push_include_buffer("<godot_cpp/variant/variant.hpp>");
					current->push_buffer("Variant ");
					gen_identifier(pattern->bind);
					current->push_buffer(" = ");
					gen_expression(p_match->test);
					current->push_buffer(";\n");
					break;
				case GDScriptParser::PatternNode::PT_ARRAY: {
					bool index_backwards = false;
					for (int k = 0; k < pattern->array.size(); k++) {
						int index = k;
						if (index_backwards) {
							index = pattern->array.size() - k + 1;
						}
						switch (pattern->array[k]->pattern_type) {
							case GDScriptParser::PatternNode::PT_REST:
								index_backwards = true;
								break;
							case GDScriptParser::PatternNode::PT_BIND:
								current->push_include_buffer("<godot_cpp/variant/variant.hpp>");
								current->push_buffer("Variant ");
								gen_identifier(pattern->array[k]->bind);
								current->push_buffer(" = ");
								gen_expression(p_match->test);
								current->push_buffer("[");
								if (index_backwards) {
									gen_expression(p_match->test);
									current->push_buffer(".size() -");
								}
								current->push_buffer(itos(index));
								current->push_buffer("]");
								current->push_buffer(";\n");
								break;
							default:
								break;
						}
					}
				} break;
				case GDScriptParser::PatternNode::PT_DICTIONARY: {
					// Broken: causes crash, also casting need
					for (int k = 0; k < pattern->dictionary.size(); k++) {
						if (pattern->dictionary[k].value_pattern != nullptr) {
							switch (pattern->dictionary[k].value_pattern->pattern_type) {
								case GDScriptParser::PatternNode::PT_BIND:
									current->push_include_buffer("<godot_cpp/variant/variant.hpp>");
									current->push_buffer("Variant ");
									gen_identifier(pattern->dictionary[k].value_pattern->bind);
									current->push_buffer(" = ");
									gen_expression(p_match->test);
									current->push_buffer("[");
									gen_expression(pattern->dictionary[k].key);
									current->push_buffer("];");
									break;
								default:
									break;
							}
						}
					}
				} break;
				default:
					break;
			}
		}

		if (branch->guard_body != nullptr) {
			current->push_buffer("\n if (");
			for (int j = 0; j < branch->guard_body->statements.size(); j++) {
				GDScriptParser::Node *guard = branch->guard_body->statements[j];
				current->push_buffer("(");
				gen_expression(static_cast<GDScriptParser::ExpressionNode *>(guard));
				current->push_buffer(")");
				if (j < branch->guard_body->statements.size() - 1) {
					current->push_buffer(" && ");
				}
			}
			current->push_buffer(") {\n");
			gen_suite(branch->block);
			current->push_buffer("}\n");
		} else {
			gen_suite(branch->block);
		}

		current->decrement_indent_level_buffer();
		current->push_buffer("}\n");
	}
}

void GDScriptCPPGen::gen_preload(const GDScriptParser::PreloadNode *p_preload) {
	if (current->preload_cache.has(p_preload->resolved_path)) {
		return;
	}
	current->push_include_buffer("<godot_cpp/classes/resource_loader.hpp>");
	current->push_buffer("preload[" + itos(current->preload_cache.size()) + "]");
	current->preload_cache.append(p_preload->resolved_path);
}

void GDScriptCPPGen::gen_return(const GDScriptParser::ReturnNode *p_return) {
	current->push_include_buffer(get_include(p_return->get_datatype()));
	current->push_buffer("return");
	if (p_return->return_value != nullptr) {
		current->push_buffer(" ");
		gen_expression(p_return->return_value);
	}
	current->end_line_buffer();
}

void GDScriptCPPGen::gen_self(const GDScriptParser::SelfNode *p_self) {
	current->push_buffer("this");
	if (p_self->current_class->identifier != nullptr) {
		current->push_buffer(".");
		gen_identifier(p_self->current_class->identifier);
	}
}

void GDScriptCPPGen::gen_statement(const GDScriptParser::Node *p_statement) {
	current->push_include_buffer(get_include(p_statement->get_datatype()));
	switch (p_statement->type) {
		case GDScriptParser::Node::VARIABLE:
			gen_variable(static_cast<const GDScriptParser::VariableNode *>(p_statement));
			break;
		case GDScriptParser::Node::CONSTANT:
			gen_constant(static_cast<const GDScriptParser::ConstantNode *>(p_statement));
			break;
		case GDScriptParser::Node::IF:
			gen_if(static_cast<const GDScriptParser::IfNode *>(p_statement));
			break;
		case GDScriptParser::Node::FOR:
			gen_for(static_cast<const GDScriptParser::ForNode *>(p_statement));
			break;
		case GDScriptParser::Node::WHILE:
			gen_while(static_cast<const GDScriptParser::WhileNode *>(p_statement));
			break;
		case GDScriptParser::Node::MATCH:
			gen_match(static_cast<const GDScriptParser::MatchNode *>(p_statement));
			break;
		case GDScriptParser::Node::RETURN:
			gen_return(static_cast<const GDScriptParser::ReturnNode *>(p_statement));
			break;
		case GDScriptParser::Node::BREAK:
			current->push_buffer("break");
			current->end_line_buffer();
			break;
		case GDScriptParser::Node::CONTINUE:
			current->push_buffer("continue");
			current->end_line_buffer();
			break;
		case GDScriptParser::Node::ASSERT:
		case GDScriptParser::Node::PASS:
		case GDScriptParser::Node::BREAKPOINT:
			return;
		case GDScriptParser::Node::ASSIGNMENT:
			gen_assignment(static_cast<const GDScriptParser::AssignmentNode *>(p_statement));
			break;
		default:
			if (p_statement->is_expression()) {
				gen_expression(static_cast<const GDScriptParser::ExpressionNode *>(p_statement));
				current->end_line_buffer();
			}
			break;
	}
}

void GDScriptCPPGen::gen_subscript(const GDScriptParser::SubscriptNode *p_subscript) {
	gen_expression(p_subscript->base);
	if (p_subscript->is_attribute) {
		current->push_buffer(".");
		gen_identifier(p_subscript->attribute);
	} else {
		current->push_buffer("[ ");
		gen_expression(p_subscript->index);
		current->push_buffer(" ]");
	}
}

void GDScriptCPPGen::gen_suite(const GDScriptParser::SuiteNode *p_suite) {
	for (int i = 0; i < p_suite->statements.size(); i++) {
		gen_statement(p_suite->statements[i]);
	}
}

void GDScriptCPPGen::gen_ternary_op(const GDScriptParser::TernaryOpNode *p_ternary_op) {
	current->push_buffer("(");
	gen_expression(p_ternary_op->condition);
	current->push_buffer(") ? ");
	gen_expression(p_ternary_op->true_expr);
	current->push_buffer(" : ");
	gen_expression(p_ternary_op->false_expr);
}

void GDScriptCPPGen::gen_type(const GDScriptParser::TypeNode *p_type) {
	if (p_type->type_chain.is_empty()) {
		current->push_buffer("void");
	} else {
		for (int i = 0; i < p_type->type_chain.size(); i++) {
			if (i > 0) {
				current->push_buffer(".");
			}
			current->push_include_buffer(get_include(p_type->type_chain[i]->get_datatype()));
			current->push_buffer(p_type->type_chain[i]->name);
		}
	}
}

void GDScriptCPPGen::gen_type_test(const GDScriptParser::TypeTestNode *p_type) {
	if (p_type->is_constant) {
		current->push_buffer("/* reduced type test */");
		current->push_buffer(p_type->reduced_value.booleanize() ? "(true)" : "(false)");
		return;
	}
	current->push_include_buffer("<godot_cpp/classes/object.hpp>");
	current->push_buffer("(Object::cast_to<");
	gen_type(p_type->test_type);
	current->push_buffer(">(");
	gen_expression(p_type->operand);
	current->push_buffer(") != nullptr)");
}

void GDScriptCPPGen::gen_unary_op(const GDScriptParser::UnaryOpNode *p_unary_op) {
	current->push_buffer("(");
	switch (p_unary_op->operation) {
		case GDScriptParser::UnaryOpNode::OP_POSITIVE:
			current->push_buffer("+");
			break;
		case GDScriptParser::UnaryOpNode::OP_NEGATIVE:
			current->push_buffer("-");
			break;
		case GDScriptParser::UnaryOpNode::OP_LOGIC_NOT:
			current->push_buffer("!");
			break;
		case GDScriptParser::UnaryOpNode::OP_COMPLEMENT:
			current->push_buffer("~");
			break;
	}
	gen_expression(p_unary_op->operand);
	current->push_buffer(")");
}

void GDScriptCPPGen::gen_variable(const GDScriptParser::VariableNode *p_variable) {
	current->push_include_buffer(get_include(p_variable->get_datatype()));
	if (p_variable->is_static) {
		current->push_buffer("inline static ");
	}
	current->push_buffer(get_datatype_name(p_variable->get_datatype()) + " ");
	gen_identifier(p_variable->identifier);
	if (!p_variable->onready && p_variable->initializer != nullptr) {
		current->push_buffer(" = ");
		if (get_datatype_name(p_variable->get_datatype()).begins_with("TypedDictionary")) {
			current->push_buffer(get_datatype_name(p_variable->get_datatype()) + "(");
		}
		gen_expression(p_variable->initializer);
		if (get_datatype_name(p_variable->get_datatype()).begins_with("TypedDictionary")) {
			current->push_buffer(")");
		}
	}
	current->end_line_buffer();
}

void GDScriptCPPGen::gen_while(const GDScriptParser::WhileNode *p_while) {
	current->push_buffer("while (");
	gen_expression(p_while->condition);
	current->push_buffer(") {\n");
	current->increment_indent_level_buffer();
	gen_suite(p_while->loop);
	current->decrement_indent_level_buffer();
	current->push_buffer("}\n");
}

void GDScriptCPPGen::_bind_methods() {
	ClassDB::bind_method(D_METHOD("generate", "file_path"), &GDScriptCPPGen::generate);
}
