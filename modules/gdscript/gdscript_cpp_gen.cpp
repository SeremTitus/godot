/**************************************************************************/
/*  gdscript_cpp_gen.cpp                                                  */
/**************************************************************************/
/*                         This file is part of:                          */
/*                             GODOT ENGINE                               */
/*                        https://godotengine.org                         */
/**************************************************************************/
/* Copyright (c) 2014-present Godot Engine contributors (see AUTHORS.md). */
/* Copyright (c) 2007-2014 Juan Linietsky, Ariel Manzur.                  */
/*                                                                        */
/* Permission is hereby granted, free of charge, to any person obtaining  */
/* a copy of this software and associated documentation files (the        */
/* "Software"), to deal in the Software without restriction, including    */
/* without limitation the rights to use, copy, modify, merge, publish,    */
/* distribute, sublicense, and/or sell copies of the Software, and to     */
/* permit persons to whom the Software is furnished to do so, subject to  */
/* the following conditions:                                              */
/*                                                                        */
/* The above copyright notice and this permission notice shall be         */
/* included in all copies or substantial portions of the Software.        */
/*                                                                        */
/* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,        */
/* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF     */
/* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. */
/* IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY   */
/* CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,   */
/* TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE      */
/* SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.                 */
/**************************************************************************/

#include "gdscript_cpp_gen.h"

#include "core/core_constants.h"
#include "core/io/file_access.h"
#include "gdscript_cache.h"

void GDScriptCPPGen::setup_output_folder() {
	if (!DirAccess::exists(output_folder.path_join("gen"))) {
		Error err = DirAccess::make_dir_recursive_absolute(output_folder.path_join("gen"));
		ERR_FAIL_COND_MSG(err != OK, "Failed to create output folder: " + output_folder);
	}

	// Broken: zero action to get the godot-cpp by git
	String godot_cpp_folder = output_folder.path_join("godot-cpp");
	if (!DirAccess::exists(godot_cpp_folder)) {
		if (OS::get_singleton()->execute("git", { "--version" }) != OK) {
			ERR_FAIL_MSG("Git is not installed or not found in the system PATH. Please install Git to use GDScriptCPPGen.");
		}

		if (OS::get_singleton()->execute(
					"git",
					{ "clone", "--depth", "1", "-b", "4.5", "https://github.com/godotengine/godot-cpp.git", godot_cpp_folder }) != OK) {
			ERR_FAIL_MSG("Failed to clone godot-cpp extension.");
		}

		if (OS::get_singleton()->execute(
					"git",
					{ "submodule", "update", "--init", "--recursive", "--depth", "1", godot_cpp_folder }) != OK) {
			ERR_FAIL_MSG("Failed to update git submodules for godot-cpp.");
		}
	}

	if (!FileAccess::exists(output_folder.path_join("SConstruct"))) {
		Ref<FileAccess> file = FileAccess::open(output_folder.path_join("SConstruct"), FileAccess::WRITE);
		if (file.is_valid()) {
			file->store_string("# This file is generated by GDScriptCPPGen.\n");
			file->store_string(String(R"(
				#!/usr/bin/env python
				import os
				import sys

				env = SConscript("godot-cpp/SConstruct")

				env.Append(CPPPATH=["gen/"])
				sources = Glob("gen/*.cpp")

				if env["platform"] == "macos":
					library = env.SharedLibrary(
						"bin/gdscript_cpp.{}.{}.framework/gdscript_cpp.{}.{}".format(
							env["platform"], env["target"], env["platform"], env["target"]
						),
						source=sources,
					)
				elif env["platform"] == "ios":
					if env["ios_simulator"]:
						library = env.StaticLibrary(
							"bin/gdscript_cpp.{}.{}.simulator.a".format(env["platform"], env["target"]),
							source=sources,
						)
					else:
						library = env.StaticLibrary(
							"bin/gdscript_cpp.{}.{}.a".format(env["platform"], env["target"]),
							source=sources,
						)
				else:
					library = env.SharedLibrary(
						"bin/gdscript_cpp{}{}".format(env["suffix"], env["SHLIBSUFFIX"]),
						source=sources,
					)

				Default(library)
			)")
							.dedent());
			file->close();
		} else {
			ERR_PRINT("Failed to open file: SConstruct");
		}
	}

	if (!FileAccess::exists(output_folder.path_join("gen").path_join("gdscript.h"))) {
		Ref<FileAccess> file = FileAccess::open(output_folder.path_join("gen").path_join("gdscript.h"), FileAccess::WRITE);
		if (file.is_valid()) {
			file->store_string("// This file is generated by GDScriptCPPGen.\n");
			file->store_string(String(R"(
				#include <godot_cpp/variant/variant.hpp>
				#include <godot_cpp/variant/color.hpp>
				#include <godot_cpp/variant/utility_functions.hpp>
				#include <godot_cpp/classes/resource_loader.hpp>
				#include <godot_cpp/classes/object.hpp>
				#include <godot_cpp/core/class_db.hpp>
				#include <godot_cpp/core/memory.hpp>
				#include <godot_cpp/classes/json.hpp>
				#include <godot_cpp/variant/array.hpp>
				#include <godot_cpp/variant/string.hpp>
				#include <godot_cpp/Core/math_defs.hpp>
				#include <godot_cpp/classes/global_constants.hpp>
				#include <godot_cpp/variant/callable_custom.hpp>

				#include <initializer_list>

				using namespace godot;

				// === Helper ===
				template <typename T>
				class LambdaCallableCustom : public CallableCustom
				{
				private:
					T lambda;
				public:
					LambdaCallableCustom(T &p_lambda) : lambda(p_lambda) {}
					virtual uint32_t hash() const override { return (uint32_t)(uintptr_t)&lambda; }
					virtual ObjectID get_object() const override { return ObjectID((uint64_t)0); }
					virtual String get_as_text() const override { return String("[CustomLambda@[") + itos(hash()) + "]"; }
					virtual void call(const Variant **p_arguments, int p_argcount, Variant &r_return_value, GDExtensionCallError &r_call_error) const override
					{
						Array args;
						for (int i = 0; i < p_argcount; ++i)
						{
							args.push_back(*p_arguments[i]);
						}
						r_return_value = lambda(args); // Find way to call any param length (in arg...) or none
						r_call_error.error = GDEXTENSION_CALL_OK;
					}
					static bool _compare_equal_static(const CallableCustomBase *p_a, const CallableCustomBase *p_b) { return p_a == p_b; }
					static bool _compare_less_static(const CallableCustomBase *p_a, const CallableCustomBase *p_b) { return p_a < p_b; }

					virtual CompareEqualFunc get_compare_equal_func() const override { return (CompareEqualFunc)&_compare_equal_static; }
					virtual CompareLessFunc get_compare_less_func() const override { return (CompareLessFunc)&_compare_less_static; }
				};

				template <typename T>
				Callable make_lambda_callable(T &p_lambda) {
					return Callable(memnew(LambdaCallableCustom(p_lambda)));
				}

				template <typename MClass, typename... Args>
				MClass *memnew_n(const Args &...p_args) {
					Variant v = memnew(MClass);
					v.call("_init", p_args...);
					return static_cast<MClass *>((Object *)v);
				}

				// The MetaClass replicating GDScript's pattern `var node_ref = Node` ... `var new_node = node_ref.new()`
				template <typename MClass>
				class MetaClass : public RefCounted {
					GDCLASS(MetaClass, RefCounted);
					protected:
						static void _bind_methods() { ClassDB::bind_method(D_METHOD("new", "args"), &MetaClass::create_new);};
					public:
						template <typename... Args>
						MClass *create_new(const Args &...p_args) { return memnew_n<MClass>(p_args ...);}
				};

				inline Dictionary make_dict(std::initializer_list<std::pair<const Variant, Variant>> init)
				{
					Dictionary dict;
					for (const auto &p : init)
					{
						dict[p.first] = p.second;
					}
					return dict;
				}

				inline Variant evaluate(const Variant::Operator &op, const Variant &a, const Variant &b)
				{
					bool valid = false;
					Variant result;
					Variant::evaluate(op, &a, &b, result, valid);
					return result;
				}

				enum UnaryOp
				{
					POSITIVE,
					NEGATIVE,
					LOGIC_NOT,
					COMPLEMENT,
				};

				inline Variant unary_op(const UnaryOp &op, const Variant &a)
				{
					switch (a.get_type())
					{
					case Variant::BOOL:
					{
						bool v = (bool)a;
						switch (op)
						{
						case LOGIC_NOT:
							return !v;
						default:
							return v;
						}
					}
					case Variant::INT:
					{
						int64_t v = (int64_t)a;
						switch (op)
						{
						case POSITIVE:
							return +v;
						case NEGATIVE:
							return -v;
						case COMPLEMENT:
							return ~v;
						default:
							return v;
						}
					}
					case Variant::FLOAT:
					{
						double v = (double)a;
						switch (op)
						{
						case POSITIVE:
							return +v;
						case NEGATIVE:
							return -v;
						default:
							return v;
						}
					}
					case Variant::VECTOR2:
					{
						Vector2 v = (Vector2)a;
						return (op == NEGATIVE) ? -v : v;
					}
					case Variant::VECTOR2I:
					{
						Vector2i v = (Vector2i)a;
						return (op == NEGATIVE) ? -v : v;
					}
					case Variant::VECTOR3:
					{
						Vector3 v = (Vector3)a;
						return (op == NEGATIVE) ? -v : v;
					}
					case Variant::VECTOR3I:
					{
						Vector3i v = (Vector3i)a;
						return (op == NEGATIVE) ? -v : v;
					}
					case Variant::VECTOR4:
					{
						Vector4 v = (Vector4)a;
						return (op == NEGATIVE) ? -v : v;
					}
					case Variant::VECTOR4I:
					{
						Vector4i v = (Vector4i)a;
						return (op == NEGATIVE) ? -v : v;
					}
					case Variant::PLANE:
					{
						Plane v = (Plane)a;
						return (op == NEGATIVE) ? -v : v;
					}
					case Variant::QUATERNION:
					{
						Quaternion v = (Quaternion)a;
						return (op == NEGATIVE) ? -v : v;
					}
					default:
						return a;
					}
				}

				inline Variant get_indexed(const Variant &a, int64_t index)
				{
					bool valid = false;
					bool oob = false;
					Variant result = a.get_indexed(index, valid, oob);
					if (!valid || oob)
					{
						return Variant(); // return null Variant if invalid or out of bounds
					}
					return result;
				}

				inline Variant get_keyed(const Variant &a, const Variant &key)
				{
					bool valid = false;
					Variant result = a.get_keyed(key, valid);
					if (!valid)
					{
						return Variant();
					}
					return result;
				}

				inline void set_indexed(Variant &a, int64_t index, const Variant &value)
				{
					bool valid = false;
					bool oob = false;
					a.set_indexed(index, value, valid, oob);
				}

				inline void set_keyed(Variant &a, const Variant &key, const Variant &value)
				{
					bool valid = false;
					a.set_keyed(key, value, valid);
				})")
							.dedent());

			file->store_string(String(R"(
				// ====================================================================
				// GDExtension Helper Functions (Mimicking GDScript)
				// ====================================================================

				const double PI = Math_PI;
				const double TAU = Math_TAU;
				const double INF = Math_INF;

				inline int len(const Variant &p_x)
				{
					switch (p_x.get_type()){
						case Variant::STRING:
						case Variant::STRING_NAME: return String(p_x).length();
						case Variant::ARRAY: return Array(p_x).size();
						case Variant::DICTIONARY: return Dictionary(p_x).size();
						case Variant::PACKED_BYTE_ARRAY: return PackedByteArray(p_x).size();
						case Variant::PACKED_INT32_ARRAY: return PackedInt32Array(p_x).size();
						case Variant::PACKED_INT64_ARRAY: return PackedInt64Array(p_x).size();
						case Variant::PACKED_FLOAT32_ARRAY: return PackedFloat32Array(p_x).size();
						case Variant::PACKED_FLOAT64_ARRAY: return PackedFloat64Array(p_x).size();
						case Variant::PACKED_STRING_ARRAY: return PackedStringArray(p_x).size();
						case Variant::PACKED_VECTOR2_ARRAY: return PackedVector2Array(p_x).size();
						case Variant::PACKED_VECTOR3_ARRAY: return PackedVector3Array(p_x).size();
						case Variant::PACKED_VECTOR4_ARRAY: return PackedVector4Array(p_x).size();
						case Variant::PACKED_COLOR_ARRAY: return PackedColorArray(p_x).size();
						default:
							UtilityFunctions::printerr("len(): unsupported Variant type");
							return -1;
					}
				}
				inline String chr(int p_code){ return String::chr(p_code);}
				inline int ord(const String &p_chr){ return p_chr.is_empty() ? -1 : p_chr.unicode_at(0);}
				inline Color Color8(int p_r8, int p_g8, int p_b8, int p_a8 = 255) { return Color::from_rgba8(p_r8, p_g8, p_b8, p_a8);}
				inline Array range(int p_n)
				{
					Array arr;
					arr.resize(p_n);
					for (int i = 0; i < p_n; ++i)
						arr[i] = i;
					return arr;
				}
				inline Array range(int p_b, int p_n)
				{
					Array arr;
					int size = p_n - p_b;
					if (size <= 0)
						return arr;
					arr.resize(size);
					for (int i = 0; i < size; ++i)
						arr[i] = p_b + i;
					return arr;
				}
				inline Array range(int p_b, int p_n, int p_s)
				{
					Array arr;
					if (p_s == 0)
					{
						UtilityFunctions::printerr("range(): step cannot be zero");
						return arr;
					}
					if ((p_s > 0 && p_b >= p_n) || (p_s < 0 && p_b <= p_n))
						return arr;

					for (int i = p_b; (p_s > 0) ? (i < p_n) : (i > p_n); i += p_s)
						arr.push_back(i);

					return arr;
				}
				inline bool type_exists(const StringName &p_type) { return ClassDB::class_exists(p_type);}
				inline bool is_instance_of(const Variant &p_value, const Variant &p_type)
				{
					switch (p_type.get_type())
					{
					case Variant::INT:
						return p_value.get_type() == static_cast<Variant::Type>(int(p_type));
					case Variant::STRING_NAME:
					{
						StringName class_name = p_type;
						if (p_value.get_type() != Variant::OBJECT)
							return false;
						Object *obj = Object::cast_to<Object>(p_value);
						if (!obj)
							return false;
						return obj->is_class(class_name);
					}
					default:
						return false;
					}
				}
				inline Ref<Resource> load(const String &p_path) { return ResourceLoader::get_singleton()->load(p_path);}
				inline Dictionary inst_to_dict(const Variant &p_obj) { return Dictionary();}// no equivalent, Deprecated anyway
				inline Variant dict_to_inst(const Dictionary &p_dict) { return Variant(); }// no equivalent, Deprecated anyway
				inline Variant convert(const Variant &p_what, Variant::Type p_type)
				{
					switch (p_type) {
						case Variant::BOOL:return p_what.operator bool();
						case Variant::INT: return p_what.operator int64_t();
						case Variant::FLOAT: return p_what.operator double();
						case Variant::STRING: return p_what.operator String();
						case Variant::VECTOR2: return p_what.operator Vector2();
						case Variant::VECTOR2I: return p_what.operator Vector2i();
						case Variant::RECT2: return p_what.operator Rect2();
						case Variant::RECT2I: return p_what.operator Rect2i();
						case Variant::VECTOR3: return p_what.operator Vector3();
						case Variant::VECTOR3I: return p_what.operator Vector3i();
						case Variant::TRANSFORM2D: return p_what.operator Transform2D();
						case Variant::VECTOR4: return p_what.operator Vector4();
						case Variant::VECTOR4I: return p_what.operator Vector4i();
						case Variant::PLANE: return p_what.operator Plane();
						case Variant::QUATERNION: return p_what.operator Quaternion();
						case Variant::AABB: return p_what.operator godot::AABB();
						case Variant::BASIS: return p_what.operator Basis();
						case Variant::TRANSFORM3D: return p_what.operator Transform3D();
						case Variant::PROJECTION: return p_what.operator Projection();
						case Variant::COLOR: return p_what.operator Color();
						case Variant::STRING_NAME: return p_what.operator StringName();
						case Variant::NODE_PATH: return p_what.operator NodePath();
						case Variant::RID: return p_what.operator godot::RID();
						case Variant::OBJECT: return p_what.operator Object *();
						case Variant::CALLABLE: return p_what.operator Callable();
						case Variant::SIGNAL: return p_what.operator Signal();
						case Variant::DICTIONARY: return p_what.operator Dictionary();
						case Variant::ARRAY: return p_what.operator Array();
						case Variant::PACKED_BYTE_ARRAY: return p_what.operator PackedByteArray();
						case Variant::PACKED_INT32_ARRAY: return p_what.operator PackedInt32Array();
						case Variant::PACKED_INT64_ARRAY: return p_what.operator PackedInt64Array();
						case Variant::PACKED_FLOAT32_ARRAY: return p_what.operator PackedFloat32Array();
						case Variant::PACKED_FLOAT64_ARRAY: return p_what.operator PackedFloat64Array();
						case Variant::PACKED_STRING_ARRAY: return p_what.operator PackedStringArray();
						case Variant::PACKED_VECTOR2_ARRAY: return p_what.operator PackedVector2Array();
						case Variant::PACKED_VECTOR3_ARRAY: return p_what.operator PackedVector3Array();
						case Variant::PACKED_VECTOR4_ARRAY: return p_what.operator PackedVector4Array();
						case Variant::PACKED_COLOR_ARRAY: return p_what.operator PackedColorArray();
						case Variant::NIL:
						default: return p_what;
					}
				}

				template <typename... Args>
				inline void print_debug(const Args &...p_args) { UtilityFunctions::print_verbose(p_args...); }
				inline Array get_stack() { return Array(); }
				inline void print_stack() {}
			)")
							.dedent());

			file->store_string(String(R"(
				// ====================================================================
				// GDExtension Helper Functions Mimicking @GlobalScope
				// ====================================================================

				enum {
					// Variant::Type
					TYPE_NIL = Variant::Type::NIL,
					TYPE_BOOL = Variant::Type::BOOL,
					TYPE_INT = Variant::Type::INT,
					TYPE_FLOAT = Variant::Type::FLOAT,
					TYPE_STRING = Variant::Type::STRING,
					TYPE_VECTOR2 = Variant::Type::VECTOR2,
					TYPE_VECTOR2I = Variant::Type::VECTOR2I,
					TYPE_RECT2 = Variant::Type::RECT2,
					TYPE_RECT2I = Variant::Type::RECT2I,
					TYPE_VECTOR3 = Variant::Type::VECTOR3,
					TYPE_VECTOR3I = Variant::Type::VECTOR3I,
					TYPE_TRANSFORM2D = Variant::Type::TRANSFORM2D,
					TYPE_VECTOR4 = Variant::Type::VECTOR4,
					TYPE_VECTOR4I = Variant::Type::VECTOR4I,
					TYPE_PLANE = Variant::Type::PLANE,
					TYPE_QUATERNION = Variant::Type::QUATERNION,
					TYPE_AABB = Variant::Type::AABB,
					TYPE_BASIS = Variant::Type::BASIS,
					TYPE_TRANSFORM3D = Variant::Type::TRANSFORM3D,
					TYPE_PROJECTION = Variant::Type::PROJECTION,
					TYPE_COLOR = Variant::Type::COLOR,
					TYPE_STRING_NAME = Variant::Type::STRING_NAME,
					TYPE_NODE_PATH = Variant::Type::NODE_PATH,
					TYPE_RID = Variant::Type::RID,
					TYPE_OBJECT = Variant::Type::OBJECT,
					TYPE_CALLABLE = Variant::Type::CALLABLE,
					TYPE_SIGNAL = Variant::Type::SIGNAL,
					TYPE_DICTIONARY = Variant::Type::DICTIONARY,
					TYPE_ARRAY = Variant::Type::ARRAY,
					TYPE_PACKED_BYTE_ARRAY = Variant::Type::PACKED_BYTE_ARRAY,
					TYPE_PACKED_INT32_ARRAY = Variant::Type::PACKED_INT32_ARRAY,
					TYPE_PACKED_INT64_ARRAY = Variant::Type::PACKED_INT64_ARRAY,
					TYPE_PACKED_FLOAT32_ARRAY = Variant::Type::PACKED_FLOAT32_ARRAY,
					TYPE_PACKED_FLOAT64_ARRAY = Variant::Type::PACKED_FLOAT64_ARRAY,
					TYPE_PACKED_STRING_ARRAY = Variant::Type::PACKED_STRING_ARRAY,
					TYPE_PACKED_VECTOR2_ARRAY = Variant::Type::PACKED_VECTOR2_ARRAY,
					TYPE_PACKED_VECTOR3_ARRAY = Variant::Type::PACKED_VECTOR3_ARRAY,
					TYPE_PACKED_COLOR_ARRAY = Variant::Type::PACKED_COLOR_ARRAY,
					TYPE_PACKED_VECTOR4_ARRAY = Variant::Type::PACKED_VECTOR4_ARRAY,
					TYPE_MAX = Variant::Type::VARIANT_MAX,

					// Variant::Operator
					OP_EQUAL = Variant::Operator::OP_EQUAL,                   // ==
					OP_NOT_EQUAL = Variant::Operator::OP_NOT_EQUAL,           // !=
					OP_LESS = Variant::Operator::OP_LESS,                     // <
					OP_LESS_EQUAL = Variant::Operator::OP_LESS_EQUAL,         // <=
					OP_GREATER = Variant::Operator::OP_GREATER,               // >
					OP_GREATER_EQUAL = Variant::Operator::OP_GREATER_EQUAL,   // >=
					OP_ADD = Variant::Operator::OP_ADD,                       // +
					OP_SUBTRACT = Variant::Operator::OP_SUBTRACT,             // -
					OP_MULTIPLY = Variant::Operator::OP_MULTIPLY,             // *
					OP_DIVIDE = Variant::Operator::OP_DIVIDE,                 // /
					OP_NEGATE = Variant::Operator::OP_NEGATE,                 // unary -
					OP_POSITIVE = Variant::Operator::OP_POSITIVE,             // unary +
					OP_MODULE = Variant::Operator::OP_MODULE,                 // %
					OP_POWER = Variant::Operator::OP_POWER,                   // **
					OP_SHIFT_LEFT = Variant::Operator::OP_SHIFT_LEFT,         // <<
					OP_SHIFT_RIGHT = Variant::Operator::OP_SHIFT_RIGHT,       // >>
					OP_BIT_AND = Variant::Operator::OP_BIT_AND,               // &
					OP_BIT_OR = Variant::Operator::OP_BIT_OR,                 // |
					OP_BIT_XOR = Variant::Operator::OP_BIT_XOR,               // ^
					OP_BIT_NEGATE = Variant::Operator::OP_BIT_NEGATE,         // ~
					OP_AND = Variant::Operator::OP_AND,                       // &&
					OP_OR = Variant::Operator::OP_OR,                         // ||
					OP_XOR = Variant::Operator::OP_XOR,                       // logical XOR (not in GDScript)
					OP_NOT = Variant::Operator::OP_NOT,                       // !
					OP_IN = Variant::Operator::OP_IN,                         // in
					OP_MAX = Variant::Operator::OP_MAX
				};
				inline int typeof(const Variant &p_variable)
				{
					return p_variable.get_type();
				}
			)")
							.dedent());
			file->close();
		} else {
			ERR_PRINT("Failed to open file: gdscript.h");
		}
	}
}

void GDScriptCPPGen::generate(const Vector<String> &p_file_path) {
	ERR_FAIL_COND_MSG(p_file_path.is_empty(), "No files provided for GDScriptCPPGen.");

	DirAccess::remove_absolute(output_folder.path_join("gen"));
	setup_output_folder();
	for (int i = 0; i < p_file_path.size(); ++i) {
		add_file_to_queue(p_file_path[i]);
	}
	while (!file_queue.is_empty()) {
		String file_path = file_queue.pop_front();
		Error error;
		Ref<GDScriptParserRef> gdscript_parser_ref = GDScriptCache::get_parser(file_path, GDScriptParserRef::Status::FULLY_SOLVED, error, String());
		if (error != OK) {
			ERR_PRINT("Failed to get GDScript parser and analyze for file: " + file_path);
			print_line("Failed to get GDScript parser and analyze for file: " + file_path);
			continue;
		}
		GDScriptParser *parser = gdscript_parser_ref->get_parser();

		if (parser->get_tree()->type != GDScriptParser::Node::Type::CLASS) {
			ERR_PRINT("The root node is not a class in file: " + file_path + ". Only scripts with a class at the root are supported.");
			print_line("Failed to get GDScript parser and analyze for file: " + file_path);
			continue;
		}

		if (generating_classes.has(get_class_name(parser->get_tree()))) {
			current = generating_classes[get_class_name(parser->get_tree())];
		} else {
			current = memnew(GeneratingClass);
		}
		current->file_path = file_path;
		current->root_class = parser->get_tree();
		current->class_name = get_class_name(current->root_class);
		current->output_file_name = get_output_file_name(current->root_class);
		generating_classes[get_class_name(current->root_class)] = current;
		gen_class_setter_getter(current);
		current->declared_by_parent = get_declared_by_parent(current->root_class);

		if (!is_class_valid()) {
			ERR_PRINT("The class is not valid in file: " + file_path);
			print_line("Failed to validate class in file: " + file_path);
			memdelete(current);
			current = nullptr;
			continue;
		}
		gen_cpp_class();
		gen_header_class(); // after cpp for the preloads to be set
		write_header_file();
		write_cpp_file();

		GeneratedClass *generated_class = memnew(GeneratedClass);
		generated_class->class_name = current->class_name;
		generated_class->file_path = current->file_path;
		generated_class->output_file_name = current->output_file_name;
		generated_class->is_abstract = current->root_class->is_abstract;
		generated_classes.push_back(generated_class);

		print_line("Generated C++ class: " + current->class_name + " from GDScript file: " + file_path);
		print_line("Output path: " + current->output_file_name);
		print_line("Source code header:\n" + current->source_code_header);
		print_line("Source code cpp:\n" + current->source_code_cpp);

		if (current) {
			memdelete(current);
			current = nullptr;
		}
	}
	write_register_file();
}

void GDScriptCPPGen::clear() {
	class_name_cache.clear();
	taken_class_names.clear();

	if (current) {
		memdelete(current);
		current = nullptr;
	}

	for (int i = 0; i < generated_classes.size(); ++i) {
		if (generated_classes[i]) {
			memdelete(generated_classes[i]);
		}
	}
	generated_classes.clear();
}

String GDScriptCPPGen::get_class_name(const GDScriptParser::ClassNode *p_class) {
	if (class_name_cache.has(p_class->fqcn)) {
		return class_name_cache[p_class->fqcn];
	}
	String class_name = String(p_class->identifier ? p_class->identifier->name : StringName()).to_pascal_case();
	while (class_name.is_empty() || taken_class_names.has(class_name)) {
		class_name = "UnnamedClass";
		if (unnamed_class_counter > 0) {
			class_name += "_" + String::num(unnamed_class_counter) + "_";
		}
		unnamed_class_counter++;
	}
	class_name += "Gen";
	class_name_cache[p_class->fqcn] = class_name;
	taken_class_names.push_back(class_name);
	return class_name;
}

String GDScriptCPPGen::to_snake_case_no_number_split(const String &p_name) {
	String result;
	String snake_str = p_name.to_snake_case();
	for (int i = 0; i < snake_str.length(); i++) {
		char32_t c = snake_str[i];
		if (c == U'_' && i + 1 < snake_str.length() && is_digit(snake_str[i + 1])) {
			continue;
		}
		result += c;
	}
	return result;
}

String GDScriptCPPGen::get_output_file_name(const GDScriptParser::ClassNode *p_class) {
	return to_snake_case_no_number_split(get_class_name(p_class));
}

GDScriptParser::DataType GDScriptCPPGen::type_from_property(const PropertyInfo &p_property) const {
	GDScriptParser::DataType result;
	result.type_source = GDScriptParser::DataType::ANNOTATED_EXPLICIT;
	if (p_property.type == Variant::NIL && (p_property.usage & PROPERTY_USAGE_NIL_IS_VARIANT)) {
		// Variant
		result.kind = GDScriptParser::DataType::VARIANT;
		return result;
	}
	result.builtin_type = p_property.type;
	if (p_property.type == Variant::OBJECT) {
		if (ScriptServer::is_global_class(p_property.class_name)) {
			result.kind = GDScriptParser::DataType::SCRIPT;
			result.script_path = ScriptServer::get_global_class_path(p_property.class_name);
			result.native_type = ScriptServer::get_global_class_native_base(p_property.class_name);

			Ref<Script> scr = ResourceLoader::load(ScriptServer::get_global_class_path(p_property.class_name));
			if (scr.is_valid()) {
				result.script_type = scr;
			}
		} else {
			result.kind = GDScriptParser::DataType::NATIVE;
			result.native_type = p_property.class_name == StringName() ? "Object" : p_property.class_name;
		}
	} else {
		result.kind = GDScriptParser::DataType::BUILTIN;
		result.builtin_type = p_property.type;
		if (p_property.type == Variant::ARRAY && p_property.hint == PROPERTY_HINT_ARRAY_TYPE) {
			// Check element type.
			StringName elem_type_name = p_property.hint_string;
			GDScriptParser::DataType elem_type;
			elem_type.type_source = GDScriptParser::DataType::ANNOTATED_EXPLICIT;

			Variant::Type elem_builtin_type = GDScriptParser::get_builtin_type(elem_type_name);
			if (elem_builtin_type < Variant::VARIANT_MAX) {
				// Builtin type.
				elem_type.kind = GDScriptParser::DataType::BUILTIN;
				elem_type.builtin_type = elem_builtin_type;
			} else if (ClassDB::class_exists(elem_type_name)) {
				elem_type.kind = GDScriptParser::DataType::NATIVE;
				elem_type.builtin_type = Variant::OBJECT;
				elem_type.native_type = elem_type_name;
			} else if (ScriptServer::is_global_class(elem_type_name)) {
				// Just load this as it shouldn't be a GDScript.
				Ref<Script> script = ResourceLoader::load(ScriptServer::get_global_class_path(elem_type_name));
				elem_type.kind = GDScriptParser::DataType::SCRIPT;
				elem_type.builtin_type = Variant::OBJECT;
				elem_type.native_type = script->get_instance_base_type();
				elem_type.script_type = script;
			} else {
				ERR_FAIL_V_MSG(result, "Could not find element type from property hint of a typed array.");
			}
			elem_type.is_constant = false;
			result.set_container_element_type(0, elem_type);
		} else if (p_property.type == Variant::DICTIONARY && p_property.hint == PROPERTY_HINT_DICTIONARY_TYPE) {
			// Check element type.
			StringName key_elem_type_name = p_property.hint_string.get_slicec(';', 0);
			GDScriptParser::DataType key_elem_type;
			key_elem_type.type_source = GDScriptParser::DataType::ANNOTATED_EXPLICIT;

			Variant::Type key_elem_builtin_type = GDScriptParser::get_builtin_type(key_elem_type_name);
			if (key_elem_builtin_type < Variant::VARIANT_MAX) {
				// Builtin type.
				key_elem_type.kind = GDScriptParser::DataType::BUILTIN;
				key_elem_type.builtin_type = key_elem_builtin_type;
			} else if (ClassDB::class_exists(key_elem_type_name)) {
				key_elem_type.kind = GDScriptParser::DataType::NATIVE;
				key_elem_type.builtin_type = Variant::OBJECT;
				key_elem_type.native_type = key_elem_type_name;
			} else if (ScriptServer::is_global_class(key_elem_type_name)) {
				// Just load this as it shouldn't be a GDScript.
				Ref<Script> script = ResourceLoader::load(ScriptServer::get_global_class_path(key_elem_type_name));
				key_elem_type.kind = GDScriptParser::DataType::SCRIPT;
				key_elem_type.builtin_type = Variant::OBJECT;
				key_elem_type.native_type = script->get_instance_base_type();
				key_elem_type.script_type = script;
			} else {
				ERR_FAIL_V_MSG(result, "Could not find element type from property hint of a typed dictionary.");
			}
			key_elem_type.is_constant = false;

			StringName value_elem_type_name = p_property.hint_string.get_slicec(';', 1);
			GDScriptParser::DataType value_elem_type;
			value_elem_type.type_source = GDScriptParser::DataType::ANNOTATED_EXPLICIT;

			Variant::Type value_elem_builtin_type = GDScriptParser::get_builtin_type(value_elem_type_name);
			if (value_elem_builtin_type < Variant::VARIANT_MAX) {
				// Builtin type.
				value_elem_type.kind = GDScriptParser::DataType::BUILTIN;
				value_elem_type.builtin_type = value_elem_builtin_type;
			} else if (ClassDB::class_exists(value_elem_type_name)) {
				value_elem_type.kind = GDScriptParser::DataType::NATIVE;
				value_elem_type.builtin_type = Variant::OBJECT;
				value_elem_type.native_type = value_elem_type_name;
			} else if (ScriptServer::is_global_class(value_elem_type_name)) {
				// Just load this as it shouldn't be a GDScript.
				Ref<Script> script = ResourceLoader::load(ScriptServer::get_global_class_path(value_elem_type_name));
				value_elem_type.kind = GDScriptParser::DataType::SCRIPT;
				value_elem_type.builtin_type = Variant::OBJECT;
				value_elem_type.native_type = script->get_instance_base_type();
				value_elem_type.script_type = script;
			} else {
				ERR_FAIL_V_MSG(result, "Could not find element type from property hint of a typed dictionary.");
			}
			value_elem_type.is_constant = false;

			result.set_container_element_type(0, key_elem_type);
			result.set_container_element_type(1, value_elem_type);
		} else if (p_property.type == Variant::INT) {
			// enum use plain int for now
		}
	}
	return result;
}

HashMap<String, GDScriptParser::DataType> GDScriptCPPGen::get_declared_by_parent(const GDScriptParser::ClassNode *p_class) {
	HashMap<String, GDScriptParser::DataType> declared_list; // <member name, return type or kind>

	if (!p_class) {
		return declared_list;
	}

	auto collect_native = [&](const StringName &native_name) {
		if (native_name.is_empty()) {
			return;
		}

		List<PropertyInfo> properties;
		ClassDB::get_property_list(native_name, &properties, true);
		for (const PropertyInfo &property : properties) {
			if (!declared_list.has(property.name)) {
				declared_list.insert(property.name, type_from_property(property));
			}
		}

		List<MethodInfo> methods;
		ClassDB::get_method_list(native_name, &methods, true);
		for (const MethodInfo &method : methods) {
			if (!declared_list.has(method.name)) {
				declared_list.insert(method.name, type_from_property(method.return_val));
			}
		}
	};

	collect_native(p_class->base_type.native_type);

	Vector<const GDScriptParser::ClassNode *> base_classes;
	const GDScriptParser::ClassNode *base_class = p_class->base_type.class_type;
	while (base_class) {
		base_classes.append(base_class);
		base_class = base_class->base_type.class_type;
	}

	for (const GDScriptParser::ClassNode *cls : base_classes) {
		for (const GDScriptParser::ClassNode::Member &member : cls->members) {
			String member_name = member.get_name();
			if (declared_list.has(member_name)) {
				continue;
			}

			declared_list.insert(member_name, member.get_datatype());
		}

		collect_native(cls->base_type.native_type);
	}

	return declared_list;
}

String GDScriptCPPGen::get_include(const GDScriptParser::DataType p_datatype) {
	if (p_datatype != GDScriptParser::DataType()) {
		return "";
	}
	switch (p_datatype.kind) {
		case GDScriptParser::DataType::NATIVE:
			return "<godot_cpp/classes/" + to_snake_case_no_number_split(String(p_datatype.native_type)) + ".hpp>";
		case GDScriptParser::DataType::SCRIPT:
			return "<godot_cpp/classes/script.hpp>";
		case GDScriptParser::DataType::CLASS:
			if (p_datatype.class_type->outer) {
				// Inner class are contained in its parents class file.
				GDScriptParser::ClassNode *outer_class = p_datatype.class_type->outer;
				GDScriptParser::ClassNode *outer_most_class = outer_class;
				while (outer_class) {
					outer_class = outer_class->outer;
					if (outer_class) {
						outer_most_class = outer_class;
					}
				}
				return "\"" + get_output_file_name(outer_most_class) + ".h\"";
			}
			return "\"" + get_output_file_name(p_datatype.class_type) + ".h\"";
		case GDScriptParser::DataType::VARIANT:
			return "<godot_cpp/variant/variant.hpp>";
		case GDScriptParser::DataType::BUILTIN:
			switch (p_datatype.builtin_type) {
				case Variant::NIL:
				case Variant::BOOL:
				case Variant::INT:
				case Variant::FLOAT:
					return "";
				case Variant::OBJECT:
					return "<godot_cpp/classes/object.hpp>";
				default:
					break;
			}
			if (p_datatype.builtin_type == Variant::ARRAY && p_datatype.has_container_element_type(0)) {
				return "<godot_cpp/variant/typed_array.hpp>";
			}
			if (p_datatype.builtin_type == Variant::DICTIONARY && p_datatype.has_container_element_types()) {
				return "<godot_cpp/variant/typed_dictionary.hpp>";
			}
			return "<godot_cpp/variant/" + to_snake_case_no_number_split(Variant::get_type_name(p_datatype.builtin_type)) + ".hpp>";
		default:
			break;
	}
	return "";
}

String GDScriptCPPGen::get_datatype_name(const GDScriptParser::DataType p_datatype, bool has_void) {
	if (p_datatype != GDScriptParser::DataType()) {
		return "";
	}
	switch (p_datatype.kind) {
		case GDScriptParser::DataType::NATIVE:
			return String(p_datatype.native_type);
		case GDScriptParser::DataType::CLASS: {
			PackedStringArray outer_class_names;
			GDScriptParser::ClassNode *outer_class = p_datatype.class_type->outer;
			while (outer_class) {
				outer_class_names.append(get_class_name(outer_class));
				outer_class = outer_class->outer;
			}
			outer_class_names.reverse();
			String result;
			for (String outer_class_name : outer_class_names) {
				result += outer_class_name + "::";
			}
			result += get_class_name(p_datatype.class_type);
			return result;
		} break;
		case GDScriptParser::DataType::SCRIPT:
			return "Script";
		case GDScriptParser::DataType::VARIANT:
			return "Variant";
		case GDScriptParser::DataType::BUILTIN:
			if (p_datatype.builtin_type == Variant::NIL) {
				if (has_void) {
					return "void";
				}
				return "Variant";
			}
			if (p_datatype.builtin_type == Variant::ARRAY && p_datatype.has_container_element_type(0)) {
				return vformat("TypedArray<%s>", get_datatype_name(p_datatype.get_container_element_type(0)));
			}
			if (p_datatype.builtin_type == Variant::DICTIONARY && p_datatype.has_container_element_types()) {
				return vformat("TypedDictionary<%s, %s>", get_datatype_name(p_datatype.get_container_element_type_or_variant(0)), get_datatype_name(p_datatype.get_container_element_type_or_variant(1)));
			}
			return Variant::get_type_name(p_datatype.builtin_type);
		case GDScriptParser::DataType::ENUM:
			return "int";
		default:
			break;
	}
	return p_datatype.to_string_strict();
}

GDScriptCPPGen::AccessType GDScriptCPPGen::get_access_type(const GDScriptParser::DataType p_datatype, const StringName &p_attribute) {
	if (p_datatype != GDScriptParser::DataType()) {
		return GDScriptCPPGen::AccessType::VARIANT_ACCESS;
	}

	auto get_access_type = [](const StringName &p_native_type) {
		if (p_native_type == SNAME("RefCounted") || ClassDB::is_parent_class(p_native_type, SNAME("RefCounted"))) {
			return GDScriptCPPGen::AccessType::REFCOUNTED_ACCESS;
		}
		return GDScriptCPPGen::AccessType::OBJECT_ACCESS;
	};

	switch (p_datatype.kind) {
		case GDScriptParser::DataType::NATIVE: {
			const StringName native = p_datatype.native_type;
			if (ClassDB::has_method(native, p_attribute, true)) {
				const MethodBind *mi = ClassDB::get_method(native, p_attribute);
				if (mi && mi->is_static()) {
					return GDScriptCPPGen::AccessType::SCOPE_ACCESS;
				}
			}

			if (ClassDB::has_property(native, p_attribute, true)) {
				const MethodBind *getter = ClassDB::get_method(native, ClassDB::get_property_getter(native, p_attribute));
				const MethodBind *setter = ClassDB::get_method(native, ClassDB::get_property_setter(native, p_attribute));
				if ((getter && getter->is_static()) || (setter && setter->is_static())) {
					return GDScriptCPPGen::AccessType::SCOPE_ACCESS;
				}
			}

			return get_access_type(native);
		} break;
		case GDScriptParser::DataType::CLASS: {
			if (p_datatype.class_type->has_member(p_attribute)) {
				switch (p_datatype.class_type->get_member(p_attribute).type) {
					case GDScriptParser::ClassNode::Member::Type::ENUM:
					case GDScriptParser::ClassNode::Member::Type::ENUM_VALUE:
					case GDScriptParser::ClassNode::Member::Type::CLASS:
						return GDScriptCPPGen::AccessType::SCOPE_ACCESS;
					case GDScriptParser::ClassNode::Member::Type::VARIABLE: {
						GDScriptParser::VariableNode *variable = static_cast<GDScriptParser::VariableNode *>(p_datatype.class_type->get_member(p_attribute).get_source_node());
						if (variable->is_static) {
							return GDScriptCPPGen::AccessType::SCOPE_ACCESS;
						}
					} break;
					case GDScriptParser::ClassNode::Member::Type::FUNCTION: {
						GDScriptParser::FunctionNode *function = static_cast<GDScriptParser::FunctionNode *>(p_datatype.class_type->get_member(p_attribute).get_source_node());
						if (function->is_static) {
							return GDScriptCPPGen::AccessType::SCOPE_ACCESS;
						}
					} break;
					default:
						break;
				}
			}
			StringName class_native;
			const GDScriptParser::ClassNode *base_class = p_datatype.class_type;
			while (base_class) {
				class_native = base_class->base_type.native_type;
				base_class = base_class->base_type.class_type;
			}
			return get_access_type(class_native);
		} break;
		case GDScriptParser::DataType::SCRIPT:
			return GDScriptCPPGen::AccessType::OBJECT_ACCESS;
		case GDScriptParser::DataType::VARIANT:
			return GDScriptCPPGen::AccessType::VARIANT_ACCESS;
		case GDScriptParser::DataType::BUILTIN:
			switch (p_datatype.builtin_type) {
				case Variant::NIL:
					return GDScriptCPPGen::AccessType::VARIANT_ACCESS;
				case Variant::BOOL:
				case Variant::INT:
				case Variant::FLOAT:
				case Variant::STRING:
					return GDScriptCPPGen::AccessType::NO_ACCESS;
				default:
					break;
			}
			return GDScriptCPPGen::AccessType::BUILTIN_ACCESS;
		case GDScriptParser::DataType::ENUM:
			return GDScriptCPPGen::AccessType::SCOPE_ACCESS;
		default:
			break;
	}
	return GDScriptCPPGen::AccessType::NO_ACCESS;
}

void GDScriptCPPGen::gen_class_setter_getter(GeneratingClass *p_generating_class) {
	p_generating_class->properties_setter_getter.clear();
	GDScriptParser::ClassNode *base_class = p_generating_class->root_class->base_type.class_type;
	PackedStringArray setter_getter_list;
	Vector<GDScriptParser::ClassNode *> base_classes;
	while (base_class) {
		base_classes.append(base_class);
		base_class = base_class->base_type.class_type;
		StringName class_native = base_class->base_type.native_type;
		if (!class_native.is_empty()) {
			List<PropertyInfo> properties;
			ClassDB::get_property_list(class_native, &properties, true);
			for (const PropertyInfo &property : properties) {
				GeneratingClass::SetterGetter new_setter_getter;
				new_setter_getter.getter = ClassDB::get_property_getter(class_native, property.name);
				new_setter_getter.setter = ClassDB::get_property_setter(class_native, property.name);
				p_generating_class->properties_setter_getter[property.name] = new_setter_getter;
				setter_getter_list.append(new_setter_getter.setter);
				setter_getter_list.append(new_setter_getter.getter);
			}
		}
	}

	for (GDScriptParser::ClassNode *current_base_class : base_classes) {
		for (const GDScriptParser::ClassNode::Member &member : current_base_class->members) {
			switch (member.type) {
				case GDScriptParser::ClassNode::Member::VARIABLE: {
					GDScriptParser::VariableNode *variable = static_cast<GDScriptParser::VariableNode *>(member.get_source_node());
					GeneratingClass::SetterGetter new_setter_getter;
					if (variable->property == GDScriptParser::VariableNode::PROP_SETGET) {
						if (variable->setter_pointer) {
							new_setter_getter.setter = variable->setter_pointer->name;
						}
						if (variable->getter_pointer) {
							new_setter_getter.getter = variable->getter_pointer->name;
						}
					}
					if (new_setter_getter.setter.is_empty()) {
						new_setter_getter.setter = "set_" + member.get_name();
						int count = 1;
						while (current_base_class->has_member(new_setter_getter.setter) || setter_getter_list.has(new_setter_getter.setter)) {
							new_setter_getter.setter = "set_" + member.get_name() + "_" + itos(count);
							count++;
						}
					}
					if (new_setter_getter.getter.is_empty()) {
						new_setter_getter.getter = "get_" + member.get_name();
						int count = 1;
						while (current_base_class->has_member(new_setter_getter.getter) || setter_getter_list.has(new_setter_getter.getter)) {
							new_setter_getter.getter = "get_" + member.get_name() + "_" + itos(count);
							count++;
						}
					}
					p_generating_class->properties_setter_getter[member.get_name()] = new_setter_getter;
					setter_getter_list.append(new_setter_getter.setter);
					setter_getter_list.append(new_setter_getter.getter);
				} break;
				default:
					break;
			}
		}
		base_class = base_class->base_type.class_type;
	}

	for (const GDScriptParser::ClassNode::Member &member : p_generating_class->root_class->members) {
		switch (member.type) {
			case GDScriptParser::ClassNode::Member::VARIABLE: {
				GDScriptParser::VariableNode *variable = static_cast<GDScriptParser::VariableNode *>(member.get_source_node());
				GeneratingClass::SetterGetter new_setter_getter;
				if (variable->property == GDScriptParser::VariableNode::PROP_SETGET) {
					if (variable->setter_pointer) {
						new_setter_getter.setter = variable->setter_pointer->name;
					}
					if (variable->getter_pointer) {
						new_setter_getter.getter = variable->getter_pointer->name;
					}
				}
				if (new_setter_getter.setter.is_empty()) {
					new_setter_getter.to_generate_setter = true;
					new_setter_getter.setter = "set_" + member.get_name();
					int count = 1;
					while (p_generating_class->root_class->has_member(new_setter_getter.setter) || setter_getter_list.has(new_setter_getter.setter)) {
						new_setter_getter.setter = "set_" + member.get_name() + "_" + itos(count);
						count++;
					}
					if (variable->setter_parameter) {
						new_setter_getter.setter_param_name = variable->setter_parameter->name;
					} else {
						new_setter_getter.setter_param_name = "p_new_value";
						count = 1;
						while (p_generating_class->root_class->has_member(new_setter_getter.setter_param_name) || setter_getter_list.has(new_setter_getter.setter_param_name)) {
							new_setter_getter.setter_param_name = "p_new_value_" + itos(count);
							count++;
						}
					}
				}
				if (new_setter_getter.getter.is_empty()) {
					new_setter_getter.to_generate_getter = true;
					new_setter_getter.getter = "get_" + member.get_name();
					int count = 1;
					while (p_generating_class->root_class->has_member(new_setter_getter.getter) || setter_getter_list.has(new_setter_getter.getter)) {
						new_setter_getter.getter = "get_" + member.get_name() + "_" + itos(count);
						count++;
					}
				}
				p_generating_class->properties_setter_getter[member.get_name()] = new_setter_getter;
				setter_getter_list.append(new_setter_getter.setter);
				setter_getter_list.append(new_setter_getter.getter);
			} break;
			default:
				break;
		}
	}
}

String GDScriptCPPGen::get_property_setter_if_property(const GDScriptParser::DataType p_datatype, const StringName &p_name) {
	if (p_datatype != GDScriptParser::DataType() || p_name.is_empty()) {
		return "";
	}
	switch (p_datatype.kind) {
		case GDScriptParser::DataType::NATIVE:
			return ClassDB::get_property_setter(p_datatype.native_type, p_name);
		case GDScriptParser::DataType::CLASS: {
			if (!generating_classes.has(get_class_name(p_datatype.class_type))) {
				GeneratingClass *new_generating_class = memnew(GeneratingClass);
				new_generating_class->root_class = p_datatype.class_type;
				gen_class_setter_getter(new_generating_class);
				generating_classes[get_class_name(p_datatype.class_type)] = new_generating_class;
			}
			if (generating_classes[get_class_name(p_datatype.class_type)]->properties_setter_getter.has(p_name)) {
				return generating_classes[get_class_name(p_datatype.class_type)]->properties_setter_getter[p_name].setter;
			}
		} break;
		case GDScriptParser::DataType::SCRIPT:
		case GDScriptParser::DataType::VARIANT:
		case GDScriptParser::DataType::BUILTIN:
		case GDScriptParser::DataType::ENUM:
		default:
			break;
	}
	return "";
}

String GDScriptCPPGen::get_property_getter_if_property(const GDScriptParser::DataType p_datatype, const StringName &p_name) {
	if (p_datatype != GDScriptParser::DataType() || p_name.is_empty()) {
		return "";
	}
	switch (p_datatype.kind) {
		case GDScriptParser::DataType::NATIVE:
			return ClassDB::get_property_getter(p_datatype.native_type, p_name);
		case GDScriptParser::DataType::CLASS: {
			if (!generating_classes.has(get_class_name(p_datatype.class_type))) {
				GeneratingClass *new_generating_class = memnew(GeneratingClass);
				new_generating_class->root_class = p_datatype.class_type;
				gen_class_setter_getter(new_generating_class);
				generating_classes[get_class_name(p_datatype.class_type)] = new_generating_class;
			}
			if (generating_classes[get_class_name(p_datatype.class_type)]->properties_setter_getter.has(p_name)) {
				return generating_classes[get_class_name(p_datatype.class_type)]->properties_setter_getter[p_name].getter;
			}
		} break;
		case GDScriptParser::DataType::VARIANT:
		case GDScriptParser::DataType::SCRIPT:
		case GDScriptParser::DataType::BUILTIN:
		case GDScriptParser::DataType::ENUM:
		default:
			break;
	}
	return "";
}

bool GDScriptCPPGen::is_method(const GDScriptParser::DataType p_datatype, const StringName &p_name) {
	if (p_datatype != GDScriptParser::DataType() || p_name.is_empty()) {
		return false;
	}

	switch (p_datatype.kind) {
		case GDScriptParser::DataType::NATIVE:
			return ClassDB::has_method(p_datatype.native_type, p_name);
		case GDScriptParser::DataType::CLASS: {
			GDScriptParser::ClassNode *cls = p_datatype.class_type;
			while (cls) {
				if (cls->has_function(p_name)) {
					return true;
				}
				if (!cls->base_type.native_type.is_empty() && ClassDB::has_method(cls->base_type.native_type, p_name)) {
					return true;
				}
				cls = cls->base_type.class_type;
			}
			return false;
		} break;
		case GDScriptParser::DataType::VARIANT:
		case GDScriptParser::DataType::SCRIPT:
		case GDScriptParser::DataType::BUILTIN:
		case GDScriptParser::DataType::ENUM:
		default:
			break;
	}
	return false;
}

bool GDScriptCPPGen::is_utility_function(const String p_name) {
	return utility_functions.has(p_name);
}

void GDScriptCPPGen::write_header_file() {
	ERR_FAIL_COND_MSG(!current, "Current is null.");
	String header_file_path = output_folder.path_join("gen").path_join(current->output_file_name + ".h");
	Ref<FileAccess> file = FileAccess::open(header_file_path, FileAccess::WRITE);
	if (file.is_valid()) {
		file->store_string("// This file is generated by GDScriptCPPGen.\n");
		file->store_string("// Generated based on GDScript file: " + current->file_path + "\n\n");
		file->store_string("#pragma once\n\n");
		file->store_string("#include <godot_cpp/variant/utility_functions.hpp>\n");
		file->store_string("#include \"gdscript.h\"\n");
		for (const String &include : current->includes_header) {
			file->store_string("#include " + include + "\n");
		}
		file->store_string("using namespace godot;\n\n");
		file->store_string("\n" + current->source_code_header + "\n");
		file->close();
	} else {
		ERR_PRINT("Failed to open file: " + header_file_path);
	}
}

void GDScriptCPPGen::write_cpp_file() {
	ERR_FAIL_COND_MSG(!current, "Current is null.");
	String cpp_file_path = output_folder.path_join("gen").path_join(current->output_file_name + ".cpp");
	Ref<FileAccess> file = FileAccess::open(cpp_file_path, FileAccess::WRITE);
	if (file.is_valid()) {
		file->store_string("// This file is generated by GDScriptCPPGen.\n");
		file->store_string("// Generated based on GDScript file: " + current->file_path + "\n\n");
		file->store_string("#include \"" + current->output_file_name + ".h\"\n");
		for (const String &include : current->includes_cpp) {
			if (include == current->output_file_name + ".h") {
				continue;
			}
			file->store_string("#include " + include + "\n");
		}
		file->store_string("\n" + current->source_code_cpp + "\n");
		file->close();
	} else {
		ERR_PRINT("Failed to open file: " + cpp_file_path);
	}
}

void GDScriptCPPGen::write_register_file() {
	String header_file_path = output_folder.path_join("gen").path_join("register_types.h");
	Ref<FileAccess> file = FileAccess::open(header_file_path, FileAccess::WRITE);
	if (file.is_valid()) {
		file->store_string("// This file is generated by GDScriptCPPGen.\n");
		file->store_string("#pragma once\n\n");
		file->store_string("#include <godot_cpp/core/class_db.hpp>\n");
		file->store_string("using namespace godot;\n\n");
		file->store_string("void initialize_gdscript_cpp_module(ModuleInitializationLevel p_level);\n");
		file->store_string("void uninitialize_gdscript_cpp_module(ModuleInitializationLevel p_level);\n");
		file->close();
	} else {
		ERR_PRINT("Failed to open file: " + header_file_path);
	}

	String cpp_file_path = output_folder.path_join("gen").path_join("register_types.cpp");
	file = FileAccess::open(cpp_file_path, FileAccess::WRITE);
	if (file.is_valid()) {
		file->store_string("// This file is generated by GDScriptCPPGen.\n");
		file->store_string("#include \"register_types.h\"\n\n");
		file->store_string("#include <gdextension_interface.h>\n");
		file->store_string("#include <godot_cpp/core/defs.hpp>\n");
		file->store_string("#include <godot_cpp/godot.hpp>\n\n");
		for (const GeneratedClass *generated_class : generated_classes) {
			file->store_string("#include \"" + generated_class->output_file_name + ".h\"\n");
		}
		file->store_string("\nusing namespace godot;\n");
		file->store_string("void initialize_gdscript_cpp_module(ModuleInitializationLevel p_level) {\n");
		file->store_string("\tif (p_level != MODULE_INITIALIZATION_LEVEL_SCENE) { return; }\n\n");
		for (const GeneratedClass *generated_class : generated_classes) {
			if (generated_class->is_abstract) {
				file->store_string("\tGDREGISTER_ABSTRACT_CLASS(" + generated_class->class_name + ");\n");
			} else {
				file->store_string("\tGDREGISTER_CLASS(" + generated_class->class_name + ");\n");
			}
		}
		file->store_string("}\n");
		file->store_string("void uninitialize_gdscript_cpp_module(ModuleInitializationLevel p_level) {\n\tif (p_level != MODULE_INITIALIZATION_LEVEL_SCENE) { return; }\n");
		file->store_string("}\n");
		file->store_string(String(R"(
		extern "C" {
		// Initialization.
		GDExtensionBool GDE_EXPORT gdscript_cpp_init(GDExtensionInterfaceGetProcAddress p_get_proc_address, const GDExtensionClassLibraryPtr p_library, GDExtensionInitialization *r_initialization) {
			godot::GDExtensionBinding::InitObject init_obj(p_get_proc_address, p_library, r_initialization);

			init_obj.register_initializer(initialize_gdscript_cpp_module);
			init_obj.register_terminator(uninitialize_gdscript_cpp_module);
			init_obj.set_minimum_library_initialization_level(MODULE_INITIALIZATION_LEVEL_SCENE);

			return init_obj.init();
		}
		}
		)")
						.dedent());
		file->close();
	} else {
		ERR_PRINT("Failed to open file: " + cpp_file_path);
	}
}

bool GDScriptCPPGen::is_class_valid() {
	if (!current) {
		ERR_PRINT("Current is null.");
		return false;
	}
	for (const GDScriptParser::ClassNode::Member &member : current->root_class->members) {
		switch (member.type) {
			case GDScriptParser::ClassNode::Member::FUNCTION:
				if (member.function->is_coroutine) {
					return false;
				}
				break;
			default:
				break;
		}
	}
	return true;
}

void GDScriptCPPGen::gen_header_class() {
	ERR_FAIL_COND_MSG(!current, "Current is null.");
	String base_class_name;
	if (current->root_class->base_type != GDScriptParser::DataType()) {
		GDScriptParser::ClassNode *base_class = current->root_class->base_type.class_type;
		current->push_include_header(get_output_file_name(base_class) + ".h");
		base_class_name = get_datatype_name(base_class->get_datatype());
	} else {
		GDScriptParser::DataType base_native_class;
		base_native_class.native_type = current->root_class->get_datatype().native_type;
		base_native_class.kind = GDScriptParser::DataType::NATIVE;
		current->push_include_header(get_include(base_native_class));
		base_class_name = get_datatype_name(base_native_class);
	}

	String class_signature = "class " + get_class_name(current->root_class);
	if (!base_class_name.is_empty()) {
		class_signature += " : public " + base_class_name;
	}
	class_signature += " {";
	current->push_line_header(class_signature);
	current->increment_indent_level_header();
	if (!base_class_name.is_empty()) {
		current->push_line_header("GDCLASS(" + get_class_name(current->root_class) + ", " + base_class_name + ");");
	}
	current->decrement_indent_level_header();
	current->push_line_header("protected:");
	current->increment_indent_level_header();
	current->push_line_header("static void _bind_methods();");
	current->decrement_indent_level_header();
	current->push_line_header("public:");
	current->increment_indent_level_header();

	PackedStringArray unnamed_enum_body;
	for (const GDScriptParser::ClassNode::Member &member : current->root_class->members) {
		if (member.type == GDScriptParser::ClassNode::Member::ENUM_VALUE) {
			unnamed_enum_body.append(String(member.enum_value.identifier->name) + " = " + itos(member.enum_value.value) + ", // Line:" + itos(member.get_source_node()->start_line));
			continue;
		}
		current->push_line_header("", "Line:" + itos(member.get_source_node()->start_line));

		switch (member.type) {
			case GDScriptParser::ClassNode::Member::CLASS: {
				GDScriptParser::ClassNode *previous_class = current->root_class;
				current->root_class = member.m_class;
				gen_header_class();
				current->root_class = previous_class;
			} break;
			case GDScriptParser::ClassNode::Member::FUNCTION: {
				String function_signature = member.function->is_abstract ? "virtual " : "";
				function_signature += member.function->is_static ? "static " : "";

				if (member.get_name() == "_init") {
					function_signature += "void ";
				} else if (current->declared_by_parent.has(member.get_name())) {
					current->push_include_header(get_include(current->declared_by_parent.get(member.get_name())));
					String return_type_name = get_datatype_name(current->declared_by_parent.get(member.get_name()), true);
					function_signature += return_type_name + " ";
				} else if (member.function->return_type) {
					current->push_include_header(get_include(member.get_datatype()));
					String return_type_name = get_datatype_name(member.get_datatype(), true);
					function_signature += return_type_name + " ";
				} else {
					function_signature += "Variant ";
				}

				function_signature += member.get_name() + "(";
				for (int i = 0; i < member.function->parameters.size(); ++i) {
					const GDScriptParser::ParameterNode *param = member.function->parameters[i];
					current->push_include_header(get_include(param->get_datatype()));
					switch (get_access_type(param->datatype)) {
						case GDScriptCPPGen::AccessType::REFCOUNTED_ACCESS:
							function_signature += +"Ref<" + get_datatype_name(param->datatype) + "> " + param->identifier->name;
							break;
						case GDScriptCPPGen::AccessType::OBJECT_ACCESS:
							function_signature += get_datatype_name(param->datatype) + " *" + param->identifier->name;
							break;
						case GDScriptCPPGen::AccessType::BUILTIN_ACCESS:
							function_signature += get_datatype_name(param->datatype) + " &" + param->identifier->name;
							break;
						default:
							function_signature += get_datatype_name(param->datatype) + " " + param->identifier->name;
							break;
					}
					if (param->initializer) {
						function_signature += " = ";
						gen_expression(param->initializer);
						function_signature += current->source_code_buffer;
						current->source_code_buffer = ""; // clears buffer
					}
					if (i < member.function->parameters.size() - 1) {
						function_signature += ", ";
					}
				}
				if (member.function->is_vararg()) {
					// Broken
					if (member.function->parameters.size() > 0) {
						function_signature += ", ";
					}
					function_signature += " const Variant **rest_";
					function_signature += (member.function->rest_parameter->identifier->name);
					function_signature += " = nullptr, GDExtensionInt rest_arg_count = 0, GDExtensionCallError &rest_error = GDExtensionCallError()";
				}

				function_signature += member.function->is_abstract ? ") = 0" : ")";

				if (current->declared_by_parent.has(member.get_name())) {
					function_signature += " override";
				}
				function_signature += ";";
				current->push_line_header(function_signature);
			} break;
			case GDScriptParser::ClassNode::Member::CONSTANT:
				gen_constant(member.constant);
				current->flush_buffer_to_header();
				break;
			case GDScriptParser::ClassNode::Member::VARIABLE: {
				gen_variable(member.variable);
				current->flush_buffer_to_header();

				String prop = member.get_name();
				String function_signature = member.variable->is_static ? "static " : "";
				String setter = get_property_setter_if_property(current->root_class->get_datatype(), prop);
				if (!setter.is_empty() && current->properties_setter_getter[prop].to_generate_setter) {
					function_signature += "void " + setter;
					function_signature += "(";
					function_signature += get_datatype_name(member.get_datatype()) + " ";
					function_signature += current->properties_setter_getter[prop].setter_param_name;
					function_signature += ");";
					current->push_line_header(function_signature);
				}

				function_signature = member.variable->is_static ? "static " : "";
				String getter = get_property_getter_if_property(current->root_class->get_datatype(), prop);
				if (!getter.is_empty() && current->properties_setter_getter[prop].to_generate_getter) {
					function_signature += get_datatype_name(member.get_datatype()) + " " + getter + "();";
					current->push_line_header(function_signature);
				}
			} break;
			case GDScriptParser::ClassNode::Member::ENUM: {
				current->push_line_header("enum " + member.get_name() + " {");
				current->increment_indent_level_header();
				for (const GDScriptParser::EnumNode::Value &E : member.m_enum->values) {
					current->push_line_header(String(E.identifier->name) + " = " + itos(E.value) + ",");
				}
				current->decrement_indent_level_header();
				current->push_line_header("};");
			} break;
			default:
				break;
		}
	}
	if (!unnamed_enum_body.is_empty()) {
		current->push_line_header("enum {");
		current->increment_indent_level_header();
		for (String line : unnamed_enum_body) {
			current->push_line_header(line);
		}
		current->decrement_indent_level_header();
		current->push_line_header("};", "");
	}

	for (int i = 0; i < current->preload_cache.size(); i++) {
		if (i == 0) {
			current->push_line_header("Array preload;");
			current->push_line_header(get_class_name(current->root_class) + "() {");
		}

		current->push_line_header("preload.append(ResourceLoader::get_singleton()->load(\"" + String(current->preload_cache[i]) + "\"));");

		if (i == current->preload_cache.size() - 1) {
			current->push_line_header("}\n");
		}
	}

	current->decrement_indent_level_header();
	current->push_line_header("};");
}

void GDScriptCPPGen::gen_cpp_class() {
	current->push_line_cpp("// Class: " + get_class_name(current->root_class));
	current->source_code_cpp += "\n";

	for (const GDScriptParser::ClassNode::Member &member : current->root_class->members) {
		switch (member.type) {
			case GDScriptParser::ClassNode::Member::VARIABLE: {
				String prop = member.get_name();
				String function_signature = "";
				String setter = get_property_setter_if_property(current->root_class->get_datatype(), prop);
				if (!setter.is_empty() && current->properties_setter_getter[prop].to_generate_setter) {
					function_signature += "void " + get_datatype_name(current->root_class->get_datatype()) + "::" + setter;
					function_signature += "(";
					function_signature += get_datatype_name(member.get_datatype()) + " ";
					function_signature += current->properties_setter_getter[prop].setter_param_name;
					function_signature += ") {";
					current->push_line_cpp(function_signature);
					current->increment_indent_level_cpp();
					if (member.variable->setter) {
						gen_suite(member.variable->setter->body);
						current->flush_buffer_to_cpp();
					} else {
						current->push_line_cpp(prop + " = " + current->properties_setter_getter[prop].setter_param_name + ";");
					}
					current->decrement_indent_level_cpp();
					current->push_line_cpp("}");
				}

				function_signature = "";
				String getter = get_property_getter_if_property(current->root_class->get_datatype(), prop);
				if (!getter.is_empty() && current->properties_setter_getter[prop].to_generate_getter) {
					function_signature += get_datatype_name(member.get_datatype()) + " " + get_datatype_name(current->root_class->get_datatype()) + "::" + getter + "() {";
					current->push_line_cpp(function_signature);
					current->increment_indent_level_cpp();
					if (member.variable->getter) {
						gen_suite(member.variable->getter->body);
						current->flush_buffer_to_cpp();
					} else {
						current->push_line_cpp("return " + prop + ";");
					}
					current->decrement_indent_level_cpp();
					current->push_line_cpp("}");
				}
			} break;
			case GDScriptParser::ClassNode::Member::FUNCTION: {
				current->source_code_cpp += "\n";
				current->push_line_cpp("", "Line:" + itos(member.get_source_node()->start_line));
				if (member.function->is_abstract) {
					continue; // No need to generate code for abstract functions
				}

				String function_signature;
				if (member.get_name() == "_init") {
					function_signature = "void ";
				} else if (current->declared_by_parent.has(member.get_name())) {
					String return_type_name = get_datatype_name(current->declared_by_parent.get(member.get_name()), true);
					function_signature = return_type_name + " ";
				} else if (member.function->return_type) {
					String return_type_name = get_datatype_name(member.get_datatype(), true);
					function_signature = return_type_name + " ";
				} else {
					function_signature = "Variant ";
				}

				function_signature += get_datatype_name(current->root_class->get_datatype()) + "::" + member.get_name() + "(";
				if (member.function->parameters.size() > 0) {
					for (int i = 0; i < member.function->parameters.size(); ++i) {
						const GDScriptParser::ParameterNode *param = member.function->parameters[i];
						switch (get_access_type(param->datatype)) {
							case GDScriptCPPGen::AccessType::REFCOUNTED_ACCESS:
								function_signature += +"Ref<" + get_datatype_name(param->datatype) + "> " + param->identifier->name;
								break;
							case GDScriptCPPGen::AccessType::OBJECT_ACCESS:
								function_signature += get_datatype_name(param->datatype) + " *" + param->identifier->name;
								break;
							case GDScriptCPPGen::AccessType::BUILTIN_ACCESS:
								function_signature += get_datatype_name(param->datatype) + " &" + param->identifier->name;
								break;
							default:
								function_signature += get_datatype_name(param->datatype) + " " + param->identifier->name;
								break;
						}

						if (i < member.function->parameters.size() - 1) {
							function_signature += ", ";
						}
					}
				}
				if (member.function->is_vararg()) {
					// Broken
					if (member.function->parameters.size() > 0) {
						function_signature += ", ";
					}
					function_signature += " const Variant **rest_";
					function_signature += (member.function->rest_parameter->identifier->name);
					function_signature += ", GDExtensionInt rest_arg_count, GDExtensionCallError &rest_error";
				}
				function_signature += ") {";
				current->push_line_cpp(function_signature);

				if (member.function->is_vararg()) {
					const GDScriptParser::ParameterNode *param = member.function->rest_parameter;
					String rest_param = get_datatype_name(param->datatype) + " " + param->identifier->name + ";";
					current->push_line_cpp(rest_param);
					rest_param = "(" + param->identifier->name + ".append(rest_" + (param->identifier->name) + "), ...)";
					current->push_line_cpp(rest_param);
				}
				current->increment_indent_level_cpp();
				gen_suite(member.function->body);
				current->flush_buffer_to_cpp();
				if (member.get_name() != "_init" && !member.function->return_type && !member.function->body->has_return) {
					current->push_line_cpp("return Variant();");
				}
				current->decrement_indent_level_cpp();
				current->push_line_cpp("}");
			} break;
			case GDScriptParser::ClassNode::Member::CLASS: {
				current->source_code_cpp += "\n";
				current->push_line_cpp("", "Line:" + itos(member.get_source_node()->start_line));
				GDScriptParser::ClassNode *previous_class = current->root_class;
				current->root_class = member.m_class;
				gen_cpp_class();
				current->root_class = previous_class;
			} break;
			default:
				break;
		}
	}

	current->push_line_cpp("void " + get_datatype_name(current->root_class->get_datatype()) + "::_bind_methods() {");
	current->increment_indent_level_cpp();

	for (const GDScriptParser::ClassNode::Member &member : current->root_class->members) {
		if (current->declared_by_parent.has(member.get_name())) {
			continue;
		}
		switch (member.type) {
			case GDScriptParser::ClassNode::Member::FUNCTION: {
				// TODO: cover vararg functions
				String bind_text;
				bind_text = "ClassDB::bind_method(D_METHOD(\"" + member.get_name() + "\"";
				if (member.function->is_static) {
					bind_text = "ClassDB::bind_static_method(\"" + get_class_name(current->root_class) + "\", D_METHOD(\"" + member.get_name() + "\"";
				}
				for (const GDScriptParser::ParameterNode *param : member.function->parameters) {
					bind_text += ", \"" + param->identifier->name + "\"";
				}
				bind_text += "), &";
				bind_text += get_datatype_name(current->root_class->get_datatype()) + "::" + member.get_name();
				for (const GDScriptParser::ParameterNode *param : member.function->parameters) {
					if (param->initializer) {
						bind_text += ",";
						gen_expression(param->initializer);
						bind_text += " DEFVAL(" + current->source_code_buffer + ")";
						current->source_code_buffer = ""; // clears buffer
					}
				}
				bind_text += ");";
				current->push_line_cpp(bind_text);
			} break;
			case GDScriptParser::ClassNode::Member::VARIABLE: {
				String cname = get_class_name(current->root_class);
				String prop = member.get_name();

				String bind_text;
				String setter = get_property_setter_if_property(current->root_class->get_datatype(), prop);
				if (!setter.is_empty() && current->properties_setter_getter[prop].to_generate_setter) {
					bind_text = "ClassDB::bind_method(D_METHOD(\"" + setter + "\"";
					if (member.variable->is_static) {
						bind_text = "ClassDB::bind_static_method(\"" + get_class_name(current->root_class) + "\", D_METHOD(\"" + setter + "\"";
					}
					bind_text += ", \"" + current->properties_setter_getter[prop].setter_param_name + "\"";
					bind_text += "), &";
					bind_text += get_datatype_name(current->root_class->get_datatype()) + "::" + setter + ");";
					current->push_line_cpp(bind_text);
				}

				String getter = get_property_getter_if_property(current->root_class->get_datatype(), prop);
				if (!getter.is_empty() && current->properties_setter_getter[prop].to_generate_getter) {
					bind_text = "ClassDB::bind_method(D_METHOD(\"" + getter + "\"), &";
					if (member.variable->is_static) {
						bind_text = "ClassDB::bind_static_method(\"" + get_class_name(current->root_class) + "\", D_METHOD(\"" + getter + "\"), &";
					}
					bind_text += get_datatype_name(current->root_class->get_datatype()) + "::" + getter + ");";
					current->push_line_cpp(bind_text);
				}

				String property_info_type = "Variant::" + member.variable->get_datatype().to_string_strict();
				if (member.variable->get_datatype().class_type || member.variable->get_datatype().native_type.is_empty()) {
					property_info_type = "Variant::OBJECT";
				}

				bind_text = "ADD_PROPERTY(PropertyInfo(" + property_info_type + ", \"" + prop + "\"), \"" + setter + "\", \"" + getter + "\");";
				current->push_line_cpp(bind_text);
			} break;
			case GDScriptParser::ClassNode::Member::CONSTANT: {
				String bind_text = "BIND_CONSTANT(" + member.get_name() + ");";
				current->push_line_cpp(bind_text);
			} break;
			case GDScriptParser::ClassNode::Member::ENUM:
				// {
				// 	for (const auto &value : member.m_enum->values) {
				// 		String bind_text = "BIND_ENUM_CONSTANT(" + member.get_name() + "::" + String(value.identifier->name) + ");";
				// 		current->push_line_cpp(bind_text);
				// 	}
				// }
				break; // Broken
			case GDScriptParser::ClassNode::Member::SIGNAL: {
				String bind_text = "ADD_SIGNAL(MethodInfo(\"" + member.get_name() + "\"";
				for (int i = 0; i < member.signal->parameters.size(); ++i) {
					if (i == 0) {
						bind_text += ", ";
					}
					const GDScriptParser::ParameterNode *param = member.signal->parameters[i];
					String param_type = "Variant::" + param->get_datatype().to_string_strict();
					if (param->get_datatype().class_type || param->get_datatype().native_type.is_empty()) {
						param_type = "Variant::OBJECT";
					}

					bind_text += "PropertyInfo(" + param_type + ", \"" + param->identifier->name + "\")";
					if (i < member.signal->parameters.size() - 1) {
						bind_text += ", ";
					}
				}
				bind_text += "));";
				current->push_line_cpp(bind_text);
			} break;
			case GDScriptParser::ClassNode::Member::ENUM_VALUE:
				// {
				// 	String bind_text = "BIND_ENUM_CONSTANT(" + String(member.enum_value.identifier->name) + ");";
				// 	current->push_line_cpp(bind_text);
				// }
				break; // Broken
			default:
				break;
		}
	}

	current->decrement_indent_level_cpp();
	current->push_line_cpp("}");
	current->source_code_cpp += "\n";
	current->push_line_cpp("// Class End: " + get_class_name(current->root_class));
	current->source_code_cpp += "\n";
}

void GDScriptCPPGen::gen_array(const GDScriptParser::ArrayNode *p_array) {
	current->push_include_buffer("<godot_cpp/variant/array.hpp>");
	current->push_buffer("Array { ");
	for (int i = 0; i < p_array->elements.size(); i++) {
		if (i > 0) {
			current->push_buffer(", ");
		}
		gen_expression(p_array->elements[i]);
	}
	current->push_buffer(" }");
}

void GDScriptCPPGen::gen_assignment(const GDScriptParser::AssignmentNode *p_assignment) {
	bool using_setter = false;
	switch (p_assignment->assignee->type) {
		case GDScriptParser::Node::IDENTIFIER: {
			String property_name = static_cast<const GDScriptParser::IdentifierNode *>(p_assignment->assignee)->name;
			String setter = get_property_setter_if_property(current->root_class->get_datatype(), property_name);
			if (!setter.is_empty()) {
				using_setter = true;
				current->push_buffer(setter + "(");
			} else {
				current->push_buffer(property_name);
			}
		} break;
		case GDScriptParser::Node::SUBSCRIPT: {
			const GDScriptParser::SubscriptNode *subscript = static_cast<const GDScriptParser::SubscriptNode *>(p_assignment->assignee);
			bool using_index_setter = !subscript->is_attribute;

			if (using_index_setter) {
				if (subscript->index->type == GDScriptParser::Node::LITERAL &&
						((static_cast<GDScriptParser::LiteralNode *>(subscript->index))->value.get_type() == Variant::INT ||
								(static_cast<GDScriptParser::LiteralNode *>(subscript->index))->value.get_type() == Variant::FLOAT)) {
					current->push_buffer("set_indexed(");
				} else {
					current->push_buffer("set_keyed(");
				}
			}

			gen_subscript(subscript, false, false);

			String property_name;
			for (int i = current->source_code_buffer.size() - 2; i >= 0; i--) {
				char32_t ch = current->source_code_buffer[i];
				if (ch == U']') {
					continue;
				}
				if (ch == U'>' || ch == U'.' || ch == U'[' || ch == U'\t' || ch == U'\n') {
					break;
				}
				property_name = String::chr(ch) + property_name;
			}
			current->source_code_buffer = current->source_code_buffer.left(current->source_code_buffer.size() - property_name.length() - (using_index_setter ? 3 : 1));

			if (subscript->base->get_datatype().kind == GDScriptParser::DataType::VARIANT) {
				using_setter = true;
				if (using_index_setter) {
					current->push_buffer(", ");
					gen_expression(subscript->index);
					current->push_buffer(", ");
				} else {
					current->push_buffer("set(\"" + property_name + "\", ");
				}
				break;
			}

			String setter = get_property_setter_if_property(subscript->base->get_datatype(), property_name);
			if (!setter.is_empty()) {
				using_setter = true;
				current->push_buffer(setter + "(");
			} else {
				if (using_index_setter) {
					current->push_buffer("[");
					gen_expression(subscript->index);
					current->push_buffer("]");
				} else {
					current->push_buffer(property_name);
				}
			}
		} break;
		default:
			break; // Unreachable.
	}

	bool use_evaluate = p_assignment->assignee->get_datatype().kind == GDScriptParser::DataType::VARIANT && p_assignment->operation != GDScriptParser::AssignmentNode::OP_NONE;
	if (using_setter && p_assignment->operation != GDScriptParser::AssignmentNode::OP_NONE) {
		if (use_evaluate) {
			current->push_buffer("evaluate(");
		} else {
			gen_expression(static_cast<const GDScriptParser::ExpressionNode *>(p_assignment->assignee), false);
		}
	} else if (use_evaluate) {
		current->push_buffer(" = evaluate(");
	}

	switch (p_assignment->operation) {
		case GDScriptParser::AssignmentNode::OP_ADDITION:
			if (use_evaluate) {
				current->push_buffer("Variant::Operator::OP_ADD");
				break;
			}
			current->push_buffer(" +");
			break;
		case GDScriptParser::AssignmentNode::OP_SUBTRACTION:
			if (use_evaluate) {
				current->push_buffer("Variant::Operator::OP_SUBTRACT");
				break;
			}
			current->push_buffer(" -");
			break;
		case GDScriptParser::AssignmentNode::OP_MULTIPLICATION:
			if (use_evaluate) {
				current->push_buffer("Variant::Operator::OP_MULTIPLY");
				break;
			}
			current->push_buffer(" *");
			break;
		case GDScriptParser::AssignmentNode::OP_DIVISION:
			if (use_evaluate) {
				current->push_buffer("Variant::Operator::OP_DIVIDE");
				break;
			}
			current->push_buffer(" /");
			break;
		case GDScriptParser::AssignmentNode::OP_MODULO:
			if (use_evaluate) {
				current->push_buffer("Variant::Operator::OP_MODULE");
				break;
			}
			current->push_buffer(" %");
			break;
		case GDScriptParser::AssignmentNode::OP_POWER:
			if (use_evaluate) {
				current->push_buffer("Variant::Operator::OP_POWER");
				break;
			}
			current->push_buffer(" **");
			break;
		case GDScriptParser::AssignmentNode::OP_BIT_SHIFT_LEFT:
			if (use_evaluate) {
				current->push_buffer("Variant::Operator::OP_SHIFT_LEFT");
				break;
			}
			current->push_buffer(" <<");
			break;
		case GDScriptParser::AssignmentNode::OP_BIT_SHIFT_RIGHT:
			if (use_evaluate) {
				current->push_buffer("Variant::Operator::OP_SHIFT_RIGHT");
				break;
			}
			current->push_buffer(" >>");
			break;
		case GDScriptParser::AssignmentNode::OP_BIT_AND:
			if (use_evaluate) {
				current->push_buffer("Variant::Operator::OP_BIT_AND");
				break;
			}
			current->push_buffer(" &");
			break;
		case GDScriptParser::AssignmentNode::OP_BIT_OR:
			if (use_evaluate) {
				current->push_buffer("Variant::Operator::OP_BIT_OR");
				break;
			}
			current->push_buffer(" |");
			break;
		case GDScriptParser::AssignmentNode::OP_BIT_XOR:
			if (use_evaluate) {
				current->push_buffer("Variant::Operator::OP_BIT_XOR");
				break;
			}
			current->push_buffer(" ^");
			break;
		case GDScriptParser::AssignmentNode::OP_NONE:
			if (!using_setter) {
				current->push_buffer(" ");
			}
			break;
	}

	if (use_evaluate) {
		current->push_buffer(", ");
		gen_expression(static_cast<const GDScriptParser::ExpressionNode *>(p_assignment->assignee), false);
		current->push_buffer(", ");
	} else if (using_setter) {
		current->push_buffer(" ");
	} else {
		current->push_buffer("= ");
	}
	gen_expression(p_assignment->assigned_value);
	if (use_evaluate) {
		current->push_buffer(")");
	}
	if (using_setter) {
		current->push_buffer(")");
	}
	current->end_line_buffer();
}

void GDScriptCPPGen::gen_await(const GDScriptParser::AwaitNode *p_await) {
	current->push_include_buffer(get_include(p_await->get_datatype()));
	// TODO: exclusion system
}

void GDScriptCPPGen::gen_binary_op(const GDScriptParser::BinaryOpNode *p_binary_op) {
	current->push_include_buffer(get_include(p_binary_op->left_operand->get_datatype()));
	current->push_include_buffer(get_include(p_binary_op->right_operand->get_datatype()));

	bool left_is_variant = p_binary_op->left_operand->get_datatype().kind == GDScriptParser::DataType::VARIANT;
	if (p_binary_op->operation == GDScriptParser::BinaryOpNode::OP_CONTENT_TEST) {
		current->push_include_buffer("<godot_cpp/variant/variant.hpp>");
		current->push_buffer("Variant(");
		gen_expression(p_binary_op->left_operand);
	} else if (left_is_variant) {
		// evaluate(const Operator &op, const Variant &a, const Variant &b)
		current->push_buffer("(bool)evaluate(");
	} else {
		gen_expression(p_binary_op->left_operand);
	}
	switch (p_binary_op->operation) {
		case GDScriptParser::BinaryOpNode::OP_ADDITION:
			if (left_is_variant) {
				current->push_buffer("Variant::Operator::OP_ADD");
				break;
			}
			current->push_buffer(" + ");
			break;
		case GDScriptParser::BinaryOpNode::OP_SUBTRACTION:
			if (left_is_variant) {
				current->push_buffer("Variant::Operator::OP_SUBTRACT");
				break;
			}
			current->push_buffer(" - ");
			break;
		case GDScriptParser::BinaryOpNode::OP_MULTIPLICATION:
			if (left_is_variant) {
				current->push_buffer("Variant::Operator::OP_MULTIPLY");
				break;
			}
			current->push_buffer(" * ");
			break;
		case GDScriptParser::BinaryOpNode::OP_DIVISION:
			if (left_is_variant) {
				current->push_buffer("Variant::Operator::OP_DIVIDE");
				break;
			}
			current->push_buffer(" / ");
			break;
		case GDScriptParser::BinaryOpNode::OP_MODULO:
			if (left_is_variant) {
				current->push_buffer("Variant::Operator::OP_MODULE");
				break;
			}
			current->push_buffer(" % ");
			break;
		case GDScriptParser::BinaryOpNode::OP_POWER:
			if (left_is_variant) {
				current->push_buffer("Variant::Operator::OP_POWER");
				break;
			}
			current->push_buffer(" ** ");
			break;
		case GDScriptParser::BinaryOpNode::OP_BIT_LEFT_SHIFT:
			if (left_is_variant) {
				current->push_buffer("Variant::Operator::OP_SHIFT_LEFT");
				break;
			}
			current->push_buffer(" << ");
			break;
		case GDScriptParser::BinaryOpNode::OP_BIT_RIGHT_SHIFT:
			if (left_is_variant) {
				current->push_buffer("Variant::Operator::OP_SHIFT_RIGHT");
				break;
			}
			current->push_buffer(" >> ");
			break;
		case GDScriptParser::BinaryOpNode::OP_BIT_AND:
			if (left_is_variant) {
				current->push_buffer("Variant::Operator::OP_BIT_AND");
				break;
			}
			current->push_buffer(" & ");
			break;
		case GDScriptParser::BinaryOpNode::OP_BIT_OR:
			if (left_is_variant) {
				current->push_buffer("Variant::Operator::OP_BIT_OR");
				break;
			}
			current->push_buffer(" | ");
			break;
		case GDScriptParser::BinaryOpNode::OP_BIT_XOR:
			if (left_is_variant) {
				current->push_buffer("Variant::Operator::OP_BIT_XOR");
				break;
			}
			current->push_buffer(" ^ ");
			break;
		case GDScriptParser::BinaryOpNode::OP_LOGIC_AND:
			if (left_is_variant) {
				current->push_buffer("Variant::Operator::OP_AND");
				break;
			}
			current->push_buffer(" && ");
			break;
		case GDScriptParser::BinaryOpNode::OP_LOGIC_OR:
			if (left_is_variant) {
				current->push_buffer("Variant::Operator::OP_OR");
				break;
			}
			current->push_buffer(" || ");
			break;
		case GDScriptParser::BinaryOpNode::OP_CONTENT_TEST:
			current->push_buffer(").in(");
			break;
		case GDScriptParser::BinaryOpNode::OP_COMP_EQUAL:
			if (left_is_variant) {
				current->push_buffer("Variant::Operator::OP_EQUAL");
				break;
			}
			current->push_buffer(" == ");
			break;
		case GDScriptParser::BinaryOpNode::OP_COMP_NOT_EQUAL:
			if (left_is_variant) {
				current->push_buffer("Variant::Operator::OP_NOT_EQUAL");
				break;
			}
			current->push_buffer(" != ");
			break;
		case GDScriptParser::BinaryOpNode::OP_COMP_LESS:
			if (left_is_variant) {
				current->push_buffer("Variant::Operator::OP_LESS");
				break;
			}
			current->push_buffer(" < ");
			break;
		case GDScriptParser::BinaryOpNode::OP_COMP_LESS_EQUAL:
			if (left_is_variant) {
				current->push_buffer("Variant::Operator::OP_LESS_EQUAL");
				break;
			}
			current->push_buffer(" <= ");
			break;
		case GDScriptParser::BinaryOpNode::OP_COMP_GREATER:
			if (left_is_variant) {
				current->push_buffer("Variant::Operator::OP_GREATER");
				break;
			}
			current->push_buffer(" > ");
			break;
		case GDScriptParser::BinaryOpNode::OP_COMP_GREATER_EQUAL:
			if (left_is_variant) {
				current->push_buffer("Variant::Operator::OP_GREATER_EQUAL");
				break;
			}
			current->push_buffer(" >= ");
			break;
	}

	if (left_is_variant) {
		current->push_buffer(", ");
		gen_expression(p_binary_op->left_operand);
		current->push_buffer(", ");
	}
	gen_expression(p_binary_op->right_operand);
	if (left_is_variant) {
		current->push_buffer(")");
	}

	if (p_binary_op->operation == GDScriptParser::BinaryOpNode::OP_CONTENT_TEST) {
		current->push_buffer(")");
	}
}

void GDScriptCPPGen::gen_call(const GDScriptParser::CallNode *p_call) {
	current->push_include_buffer(get_include(p_call->get_datatype()));

	// first class signals
	if (p_call->callee->type == GDScriptParser::Node::SUBSCRIPT && static_cast<const GDScriptParser::SubscriptNode *>(p_call->callee)->base->get_datatype().builtin_type == Variant::SIGNAL) {
		gen_expression(p_call->callee);

		bool is_emit = false;

		if (current->source_code_buffer.ends_with(".emit")) {
			current->source_code_buffer = current->source_code_buffer.left(current->source_code_buffer.size() - 6);
			is_emit = true;
		} else if (current->source_code_buffer.ends_with(".connect")) {
			current->source_code_buffer = current->source_code_buffer.left(current->source_code_buffer.size() - 9);
		}

		String signal_name;
		for (int i = current->source_code_buffer.size() - 2; i >= 0; i--) {
			char32_t ch = current->source_code_buffer[i];

			if (ch == U'>' || ch == U'.' || ch == U'\t' || ch == U'\n') {
				break;
			}
			signal_name = String::chr(ch) + signal_name;
		}

		current->source_code_buffer = current->source_code_buffer.left(current->source_code_buffer.size() - signal_name.length() - 1);

		if (is_emit) {
			current->push_buffer("emit_signal(\"");
			current->push_buffer(signal_name);
			current->push_buffer("\")");
		} else {
			current->push_buffer("connect(\"");
			current->push_buffer(signal_name);
			current->push_buffer("\"");
			for (int i = 0; i < p_call->arguments.size(); i++) {
				current->push_buffer(", ");
				gen_expression(p_call->arguments[i]);
			}
			current->push_buffer(")");
		}
		return;
	}

	bool use_variant_call = p_call->callee->type == GDScriptParser::Node::SUBSCRIPT && static_cast<const GDScriptParser::SubscriptNode *>(p_call->callee)->base->get_datatype().kind == GDScriptParser::DataType::VARIANT;
	if (p_call->is_super) {
		String base_class_name;
		if (current->root_class->base_type != GDScriptParser::DataType()) {
			GDScriptParser::ClassNode *base_class = current->root_class->base_type.class_type;
			current->push_include_header(get_output_file_name(base_class) + ".h");
			base_class_name = get_class_name(base_class);
		} else {
			GDScriptParser::DataType base_native_class;
			base_native_class.native_type = current->root_class->get_datatype().native_type;
			base_native_class.kind = GDScriptParser::DataType::NATIVE;
			current->push_include_header(get_include(base_native_class));
			base_class_name = get_datatype_name(base_native_class);
		}
		current->push_buffer(base_class_name);

		current->push_buffer("::");
		if (p_call->callee) {
			gen_expression(p_call->callee, false);
		} else {
			current->push_buffer(p_call->function_name);
		}
	} else {
		int initial_size = current->source_code_buffer.size();
		if (p_call->is_constructor) {
			current->push_buffer("memnew_n<");
		} else if (p_call->callee->type == GDScriptParser::Node::IDENTIFIER && is_utility_function(static_cast<const GDScriptParser::IdentifierNode *>(p_call->callee)->name)) {
			// @GlobalScope functions
			current->push_include_buffer("<godot_cpp/variant/utility_functions.hpp>");
			current->push_buffer("UtilityFunctions::");
		}

		gen_expression(p_call->callee, false);

		// is MetaClass Call
		if (p_call->is_constructor && !current->source_code_buffer.ends_with(get_datatype_name(p_call->get_datatype()) + "->new")) {
			current->source_code_buffer = current->source_code_buffer.left(initial_size - 1);
			use_variant_call = true;
			gen_expression(p_call->callee, false);
			current->source_code_buffer = current->source_code_buffer.left(current->source_code_buffer.size() - 6); // ->new
			current->push_buffer(".new");
		}

		if (!use_variant_call && p_call->is_constructor) {
			current->source_code_buffer = current->source_code_buffer.left(current->source_code_buffer.size() - 6); // ->new
			current->push_buffer(">");
		} else if (current->source_code_buffer.ends_with("char")) {
			current->source_code_buffer = current->source_code_buffer.erase(current->source_code_buffer.size() - 3);
		}
	}

	// calling variant use call
	if (use_variant_call) {
		String method_name;
		for (int i = current->source_code_buffer.size() - 2; i >= 0; i--) {
			char32_t ch = current->source_code_buffer[i];

			if (ch == U'.') {
				break;
			}
			method_name = String::chr(ch) + method_name;
		}
		current->source_code_buffer = current->source_code_buffer.left(current->source_code_buffer.size() - method_name.length() - 1);

		current->push_buffer("call(\"" + method_name + "\"");
		for (int i = 0; i < p_call->arguments.size(); i++) {
			current->push_buffer(", ");
			int initial_size = current->source_code_buffer.size();
			gen_expression(p_call->arguments[i]);
			// MetaClass (passed as param)
			if (current->source_code_buffer.ends_with(get_datatype_name(p_call->arguments[i]->get_datatype()))) {
				current->source_code_buffer = current->source_code_buffer.left(initial_size - 1);
				current->push_buffer("memnew(MetaClass<");
				gen_expression(p_call->arguments[i]);
				current->push_buffer(">)");
			}
		}
		current->push_buffer(")");
		return;
	}

	current->push_buffer("(");
	for (int i = 0; i < p_call->arguments.size(); i++) {
		if (i > 0) {
			current->push_buffer(" , ");
		}
		int initial_size = current->source_code_buffer.size();
		gen_expression(p_call->arguments[i]);
		// MetaClass (passed as param)
		if (current->source_code_buffer.ends_with(get_datatype_name(p_call->arguments[i]->get_datatype()))) {
			current->source_code_buffer = current->source_code_buffer.left(initial_size - 1);
			current->push_buffer("memnew(MetaClass<");
			gen_expression(p_call->arguments[i]);
			current->push_buffer(">)");
		}
	}
	current->push_buffer(")");
}

void GDScriptCPPGen::gen_cast(const GDScriptParser::CastNode *p_cast) {
	current->push_include_buffer("<godot_cpp/classes/object.hpp>");
	current->push_buffer("Object::cast_to<");
	gen_type(p_cast->cast_type);
	current->push_buffer(">(");
	gen_expression(p_cast->operand);
	current->push_buffer(")");
}

void GDScriptCPPGen::gen_constant(const GDScriptParser::ConstantNode *p_constant) {
	int initial_size = current->source_code_buffer.size();

	current->push_include_buffer(get_include(p_constant->get_datatype()));
	current->push_buffer("const ");
	switch (get_access_type(p_constant->get_datatype())) {
		case GDScriptCPPGen::AccessType::REFCOUNTED_ACCESS:
			current->push_buffer("Ref<" + get_datatype_name(p_constant->get_datatype()) + "> ");
			break;
		case GDScriptCPPGen::AccessType::OBJECT_ACCESS:
			current->push_buffer(get_datatype_name(p_constant->get_datatype()) + " *");
			break;
		default:
			current->push_buffer(get_datatype_name(p_constant->get_datatype()) + " ");
			break;
	}
	gen_identifier(p_constant->identifier, false);
	current->push_buffer(" = ");
	if (get_datatype_name(p_constant->get_datatype()).begins_with("TypedDictionary")) {
		current->push_buffer(get_datatype_name(p_constant->get_datatype()) + "(");
	}
	gen_expression(p_constant->initializer);

	// MetaClass (stored)
	if (current->source_code_buffer.ends_with(get_datatype_name(p_constant->get_datatype()))) {
		current->source_code_buffer = current->source_code_buffer.left(initial_size - 1);
		current->push_buffer("const Variant ");
		gen_identifier(p_constant->identifier, false, false);
		current->push_buffer(" = memnew(MetaClass<");
		gen_expression(p_constant->initializer);
		current->push_buffer(">)");
		current->end_line_buffer();
		return;
	}

	if (get_datatype_name(p_constant->get_datatype()).begins_with("TypedDictionary")) {
		current->push_buffer(")");
	}
	current->end_line_buffer();
}

void GDScriptCPPGen::gen_dictionary(const GDScriptParser::DictionaryNode *p_dictionary) {
	current->push_include_buffer("<godot_cpp/variant/dictionary.hpp>");
	current->push_buffer("make_dict(");
	current->push_buffer("{");
	current->increment_indent_level_buffer();
	for (int i = 0; i < p_dictionary->elements.size(); i++) {
		current->push_buffer("\n");
		current->push_buffer("{");
		gen_expression(p_dictionary->elements[i].key);
		current->push_buffer(", ");
		gen_expression(p_dictionary->elements[i].value);
		current->push_buffer("}");
		if (i + 1 < p_dictionary->elements.size()) {
			current->push_buffer(",");
		}
	}
	current->decrement_indent_level_buffer();
	current->push_buffer("})");
}

void GDScriptCPPGen::gen_expression(const GDScriptParser::ExpressionNode *p_expression, bool may_have_first_class_method) {
	current->push_include_buffer(get_include(p_expression->get_datatype()));
	switch (p_expression->type) {
		case GDScriptParser::Node::ARRAY:
			gen_array(static_cast<const GDScriptParser::ArrayNode *>(p_expression));
			break;
		case GDScriptParser::Node::ASSIGNMENT:
			gen_assignment(static_cast<const GDScriptParser::AssignmentNode *>(p_expression));
			break;
		case GDScriptParser::Node::AWAIT:
			gen_await(static_cast<const GDScriptParser::AwaitNode *>(p_expression));
			break;
		case GDScriptParser::Node::BINARY_OPERATOR:
			gen_binary_op(static_cast<const GDScriptParser::BinaryOpNode *>(p_expression));
			break;
		case GDScriptParser::Node::CALL:
			gen_call(static_cast<const GDScriptParser::CallNode *>(p_expression));
			break;
		case GDScriptParser::Node::CAST:
			gen_cast(static_cast<const GDScriptParser::CastNode *>(p_expression));
			break;
		case GDScriptParser::Node::DICTIONARY:
			gen_dictionary(static_cast<const GDScriptParser::DictionaryNode *>(p_expression));
			break;
		case GDScriptParser::Node::GET_NODE:
			gen_get_node(static_cast<const GDScriptParser::GetNodeNode *>(p_expression));
			break;
		case GDScriptParser::Node::IDENTIFIER:
			gen_identifier(static_cast<const GDScriptParser::IdentifierNode *>(p_expression), may_have_first_class_method);
			break;
		case GDScriptParser::Node::LAMBDA:
			gen_lambda(static_cast<const GDScriptParser::LambdaNode *>(p_expression));
			break;
		case GDScriptParser::Node::LITERAL:
			gen_literal(static_cast<const GDScriptParser::LiteralNode *>(p_expression));
			break;
		case GDScriptParser::Node::PRELOAD:
			gen_preload(static_cast<const GDScriptParser::PreloadNode *>(p_expression));
			break;
		case GDScriptParser::Node::SELF:
			gen_self(static_cast<const GDScriptParser::SelfNode *>(p_expression));
			break;
		case GDScriptParser::Node::SUBSCRIPT:
			gen_subscript(static_cast<const GDScriptParser::SubscriptNode *>(p_expression), may_have_first_class_method);
			break;
		case GDScriptParser::Node::TERNARY_OPERATOR:
			gen_ternary_op(static_cast<const GDScriptParser::TernaryOpNode *>(p_expression));
			break;
		case GDScriptParser::Node::TYPE_TEST:
			gen_type_test(static_cast<const GDScriptParser::TypeTestNode *>(p_expression));
			break;
		case GDScriptParser::Node::UNARY_OPERATOR:
			gen_unary_op(static_cast<const GDScriptParser::UnaryOpNode *>(p_expression));
			break;
		default:
			break;
	}
}

void GDScriptCPPGen::gen_for(const GDScriptParser::ForNode *p_for) {
	current->push_include_buffer(get_include(p_for->list->get_datatype()));
	current->push_buffer("for (auto ");
	gen_identifier(p_for->variable, false);
	current->push_buffer(" : ");
	gen_expression(p_for->list);
	current->push_buffer(") {\n");
	current->increment_indent_level_buffer();
	gen_suite(p_for->loop);
	current->decrement_indent_level_buffer();
	current->push_buffer("}\n");
}

void GDScriptCPPGen::gen_get_node(const GDScriptParser::GetNodeNode *p_get_node) {
	current->push_buffer("get_node(\"" + p_get_node->full_path + "\")");
}

void GDScriptCPPGen::gen_if(const GDScriptParser::IfNode *p_if, bool p_is_elif) {
	if (p_is_elif) {
		current->push_buffer("else if (");
	} else {
		current->push_buffer("if (");
	}
	gen_expression(p_if->condition);
	current->push_buffer(") {\n");

	current->increment_indent_level_buffer();
	gen_suite(p_if->true_block);
	current->decrement_indent_level_buffer();

	current->push_buffer("} ");

	if (p_if->false_block) {
		if (p_if->false_block->statements.size() == 1 &&
				p_if->false_block->statements[0]->type == GDScriptParser::Node::IF) {
			gen_if(static_cast<const GDScriptParser::IfNode *>(p_if->false_block->statements[0]), true);
			return;
		}
		current->push_buffer("else {");
		current->increment_indent_level_buffer();
		gen_suite(p_if->false_block);
		current->decrement_indent_level_buffer();
		current->push_buffer("}\n");
	}
}

void GDScriptCPPGen::gen_identifier(const GDScriptParser::IdentifierNode *p_identifier, bool may_have_first_class_method, bool use_getter) {
	if (p_identifier) {
		// first class methods (Local)
		if (may_have_first_class_method && is_method(current->root_class->get_datatype(), p_identifier->name)) {
			current->push_include_buffer("<godot_cpp/variant/callable.hpp>");
			current->push_buffer("Callable(this, \"");
			current->push_buffer(p_identifier->name);
			current->push_buffer("\")");
		} else {
			String property_name = p_identifier->name;
			String getter = get_property_getter_if_property(current->root_class->get_datatype(), property_name);
			if (use_getter && !getter.is_empty()) {
				current->push_buffer(getter + "()");
			} else {
				current->push_buffer(property_name);
			}
		}
	}
}

void GDScriptCPPGen::gen_lambda(const GDScriptParser::LambdaNode *p_lambda) {
	current->push_include_buffer("<godot_cpp/variant/callable.hpp>");
	current->push_buffer("make_lambda_callable([&, this](Array &p_args)");
	current->push_buffer(" -> " + get_datatype_name(p_lambda->function->get_datatype()) + " {\n");
	current->increment_indent_level_buffer();
	for (int i = 0; i < p_lambda->function->parameters.size(); ++i) {
		const GDScriptParser::ParameterNode *param = p_lambda->function->parameters[i];
		current->push_buffer(get_datatype_name(param->get_datatype()) + " " + param->identifier->name);
		current->push_buffer(" = ");
		if (param->initializer) {
			current->push_buffer("p_args.size() > " + itos(i) + "? p_args[" + itos(i) + "]");
			current->push_buffer(" : ");
			gen_expression(param->initializer);
		} else {
			current->push_buffer("p_args[" + itos(i) + "]");
		}
		current->end_line_buffer();
	}
	if (p_lambda->function->is_vararg()) {
		const GDScriptParser::ParameterNode *param = p_lambda->function->rest_parameter;
		current->push_buffer(get_datatype_name(param->get_datatype()) + " " + param->identifier->name);
		current->push_buffer(" = ");
		current->push_buffer("p_args.slice(" + itos(p_lambda->function->parameters.size()) + ")");
		current->end_line_buffer();
	}
	gen_suite(p_lambda->function->body);

	if (p_lambda->function->return_type == nullptr || get_datatype_name(p_lambda->function->get_datatype()) == "void") {
		current->push_buffer("\n");
		current->push_buffer("return Variant(); // void is not supported");
	}
	current->decrement_indent_level_buffer();
	current->push_buffer("\n})");
}

void GDScriptCPPGen::gen_literal(const GDScriptParser::LiteralNode *p_literal) {
	switch (p_literal->value.get_type()) {
		case Variant::NODE_PATH:
			current->push_include_buffer("<godot_cpp/variant/node_path.hpp>");
			current->push_buffer("NodePath(\"");
			break;
		case Variant::STRING:
			current->push_include_buffer("<godot_cpp/variant/string.hpp>");
			current->push_buffer("String(\"");
			break;
		case Variant::STRING_NAME:
			current->push_include_buffer("<godot_cpp/variant/string_name.hpp>");
			current->push_buffer("StringName(\"");
			break;
		default:
			break;
	}
	if (String(p_literal->value) == "<null>") {
		current->push_include_buffer("<godot_cpp/variant/variant.hpp>");
		current->push_buffer("Variant()");
	} else {
		current->push_buffer(String(p_literal->value).c_escape());
	}
	switch (p_literal->value.get_type()) {
		case Variant::STRING:
		case Variant::STRING_NAME:
		case Variant::NODE_PATH:
			current->push_buffer("\")");
			break;
		default:
			break;
	}
}

void GDScriptCPPGen::gen_match(const GDScriptParser::MatchNode *p_match) {
	for (int i = 0; i < p_match->branches.size(); ++i) {
		const GDScriptParser::MatchBranchNode *branch = p_match->branches[i];
		if (i > 0) {
			current->push_buffer(" else if (");
		} else {
			current->push_buffer("if (");
		}

		for (int j = 0; j < branch->patterns.size(); ++j) {
			const GDScriptParser::PatternNode *pattern = branch->patterns[j];
			if (j > 0 && !current->source_code_buffer.ends_with(" && ")) {
				current->push_buffer(" && ");
			}
			switch (pattern->pattern_type) {
				case GDScriptParser::PatternNode::PT_LITERAL:
					current->push_buffer("(Variant)");
					gen_expression(p_match->test);
					current->push_buffer(" == ");
					current->push_buffer("(Variant)");
					gen_literal(pattern->literal);
					break;
				case GDScriptParser::PatternNode::PT_WILDCARD:
				case GDScriptParser::PatternNode::PT_BIND:
					break;
				case GDScriptParser::PatternNode::PT_EXPRESSION:
					current->push_buffer("(Variant)");
					gen_expression(p_match->test);
					current->push_buffer(" == ");
					current->push_buffer("(Variant)");
					gen_expression(pattern->expression);
					break;
				case GDScriptParser::PatternNode::PT_ARRAY: {
					if (pattern->array.size() == 0) {
						current->push_buffer("(Array)(Variant)");
						gen_expression(p_match->test);
						current->push_buffer(" == Array()");
						break;
					}

					bool exact_size = true;
					for (int k = 0; k < pattern->array.size(); k++) {
						switch (pattern->array[k]->pattern_type) {
							case GDScriptParser::PatternNode::PT_REST:
								exact_size = false;
								break;
							default:
								break;
						}
					}

					bool index_backwards = false;
					for (int k = 0; k < pattern->array.size(); k++) {
						if (k > 0 && !current->source_code_buffer.ends_with(" && ")) {
							current->push_buffer(" && ");
						}

						if (k == 0) {
							current->push_buffer("((Array)(Variant)");
							gen_expression(p_match->test);
							current->push_buffer(")");
							if (exact_size) {
								current->push_buffer(".size() == " + itos(pattern->array.size()));
							} else {
								current->push_buffer(".size() >= " + itos(pattern->array.size() - 1));
							}
							current->push_buffer(" && ");
						}
						int index = k;
						if (index_backwards) {
							index = pattern->array.size() - k + 1;
						}
						switch (pattern->array[k]->pattern_type) {
							case GDScriptParser::PatternNode::PT_REST:
								index_backwards = true;
								break;
							case GDScriptParser::PatternNode::PT_LITERAL:
								current->push_buffer("(Variant)");
								current->push_buffer("((Array)(Variant)");
								gen_expression(p_match->test);
								current->push_buffer(")");
								current->push_buffer("[");
								if (index_backwards) {
									current->push_buffer("((Array)(Variant)");
									gen_expression(p_match->test);
									current->push_buffer(")");
									current->push_buffer(".size() -");
								}
								current->push_buffer(itos(index));
								current->push_buffer("]");
								current->push_buffer(" == ");
								current->push_buffer("(Variant)");
								gen_literal(pattern->array[k]->literal);
								break;
							case GDScriptParser::PatternNode::PT_EXPRESSION:
								current->push_buffer("(Variant)");
								current->push_buffer("((Array)(Variant)");
								gen_expression(p_match->test);
								current->push_buffer(")");
								current->push_buffer("[");
								if (index_backwards) {
									current->push_buffer("(Array((Variant)");
									gen_expression(p_match->test);
									current->push_buffer("))");
									current->push_buffer(".size() -");
								}
								current->push_buffer(itos(index));
								current->push_buffer("]");
								current->push_buffer(" == ");
								current->push_buffer("(Variant)");
								gen_expression(pattern->array[k]->expression);
								break;
							case GDScriptParser::PatternNode::PT_WILDCARD:
							default:
								break;
						}
					}
				} break;
				case GDScriptParser::PatternNode::PT_DICTIONARY: {
					if (pattern->dictionary.size() == 0) {
						current->push_buffer("(Dictionary)(Variant)");
						gen_expression(p_match->test);
						current->push_buffer(" == Dictionary()");
						break;
					}

					bool exact_size = true;
					for (int k = 0; k < pattern->dictionary.size(); k++) {
						if (!pattern->dictionary[k].value_pattern) {
							continue;
						}
						switch (pattern->dictionary[k].value_pattern->pattern_type) {
							case GDScriptParser::PatternNode::PT_REST:
								exact_size = false;
								break;
							default:
								break;
						}
					}

					for (int k = 0; k < pattern->dictionary.size(); k++) {
						if (k > 0 && !current->source_code_buffer.ends_with(" && ")) {
							current->push_buffer(" && ");
						}

						if (k == 0) {
							current->push_buffer("((Dictionary)(Variant)");
							gen_expression(p_match->test);
							current->push_buffer(")");
							if (exact_size) {
								current->push_buffer(".size() == " + itos(pattern->dictionary.size()));
							} else {
								current->push_buffer(".size() >= " + itos(pattern->dictionary.size() - 1));
							}
							current->push_buffer(" && ");
						}

						if (pattern->dictionary[k].key) {
							// Key can be null for rest pattern.
							current->push_buffer("((Dictionary)(Variant)");
							gen_expression(p_match->test);
							current->push_buffer(")");
							current->push_buffer(".has(");
							gen_expression(pattern->dictionary[k].key);
							current->push_buffer(")");
							if (pattern->dictionary[k].value_pattern) {
								current->push_buffer(" && ");
							}
						}
						if (pattern->dictionary[k].value_pattern) {
							switch (pattern->dictionary[k].value_pattern->pattern_type) {
								case GDScriptParser::PatternNode::PT_LITERAL:
									current->push_buffer("(Variant)");
									current->push_buffer("((Dictionary)(Variant)");
									gen_expression(p_match->test);
									current->push_buffer(")");
									current->push_buffer("[");
									gen_expression(pattern->dictionary[k].key);
									current->push_buffer("] == ");
									current->push_buffer("(Variant)");
									gen_literal(pattern->dictionary[k].value_pattern->literal);
									break;
								case GDScriptParser::PatternNode::PT_EXPRESSION:
									current->push_buffer("(Variant)");
									current->push_buffer("((Dictionary)(Variant)");
									gen_expression(p_match->test);
									current->push_buffer(")");
									current->push_buffer("[");
									gen_expression(pattern->dictionary[k].key);
									current->push_buffer("] == ");
									current->push_buffer("(Variant)");
									gen_expression(pattern->dictionary[k].value_pattern->expression);
									break;
								default:
									break;
							}
						}
					}
				} break;
				default:
					break;
			}
		}

		if (current->source_code_buffer.ends_with("else if (")) {
			current->source_code_buffer = current->source_code_buffer.left(current->source_code_buffer.size() - 5);
		} else {
			if (current->source_code_buffer.ends_with(" && ")) {
				current->source_code_buffer = current->source_code_buffer.left(current->source_code_buffer.size() - 5);
			}
			current->push_buffer(") ");
		}
		current->push_buffer("{\n");

		current->increment_indent_level_buffer();
		for (int j = 0; j < branch->patterns.size(); ++j) {
			const GDScriptParser::PatternNode *pattern = branch->patterns[j];
			switch (pattern->pattern_type) {
				case GDScriptParser::PatternNode::PT_BIND:
					current->push_include_buffer("<godot_cpp/variant/variant.hpp>");
					current->push_buffer("Variant ");
					gen_identifier(pattern->bind, false);
					current->push_buffer(" = ");
					gen_expression(p_match->test);
					current->push_buffer(";\n");
					break;
				case GDScriptParser::PatternNode::PT_ARRAY: {
					bool index_backwards = false;
					for (int k = 0; k < pattern->array.size(); k++) {
						int index = k;
						if (index_backwards) {
							index = pattern->array.size() - k + 1;
						}
						switch (pattern->array[k]->pattern_type) {
							case GDScriptParser::PatternNode::PT_REST:
								index_backwards = true;
								break;
							case GDScriptParser::PatternNode::PT_BIND:
								current->push_include_buffer("<godot_cpp/variant/variant.hpp>");
								current->push_buffer("Variant ");
								gen_identifier(pattern->array[k]->bind);
								current->push_buffer(" = ");
								current->push_buffer("((Array)(Variant)");
								gen_expression(p_match->test);
								current->push_buffer(")");
								current->push_buffer("[");
								if (index_backwards) {
									gen_expression(p_match->test);
									current->push_buffer(".size() -");
								}
								current->push_buffer(itos(index));
								current->push_buffer("]");
								current->push_buffer(";\n");
								break;
							default:
								break;
						}
					}
				} break;
				case GDScriptParser::PatternNode::PT_DICTIONARY: {
					for (int k = 0; k < pattern->dictionary.size(); k++) {
						if (pattern->dictionary[k].value_pattern) {
							switch (pattern->dictionary[k].value_pattern->pattern_type) {
								case GDScriptParser::PatternNode::PT_BIND:
									current->push_include_buffer("<godot_cpp/variant/variant.hpp>");
									current->push_buffer("Variant ");
									gen_identifier(pattern->dictionary[k].value_pattern->bind, false);
									current->push_buffer(" = ");
									current->push_buffer("((Dictionary)(Variant)");
									gen_expression(p_match->test);
									current->push_buffer(")");
									current->push_buffer("[");
									gen_expression(pattern->dictionary[k].key);
									current->push_buffer("];\n");
									break;
								default:
									break;
							}
						}
					}
				} break;
				default:
					break;
			}
		}

		if (branch->guard_body) {
			current->push_buffer("\n");
			current->push_buffer("if (");
			for (int j = 0; j < branch->guard_body->statements.size(); j++) {
				if (j > 0) {
					current->push_buffer(" && ");
				}
				GDScriptParser::Node *guard = branch->guard_body->statements[j];
				gen_expression(static_cast<GDScriptParser::ExpressionNode *>(guard));
			}
			current->push_buffer(") {\n");
			current->increment_indent_level_buffer();
			gen_suite(branch->block);
			current->decrement_indent_level_buffer();
			current->push_buffer("}\n");
		} else {
			gen_suite(branch->block);
		}

		current->decrement_indent_level_buffer();
		current->push_buffer("}");
		if (i >= p_match->branches.size() - 1) {
			current->push_buffer("\n");
		}
	}
}

void GDScriptCPPGen::gen_preload(const GDScriptParser::PreloadNode *p_preload) {
	if (current->preload_cache.has(p_preload->resolved_path)) {
		return;
	}
	current->push_include_buffer("<godot_cpp/classes/resource_loader.hpp>");
	current->push_buffer("preload[" + itos(current->preload_cache.size()) + "]");
	current->preload_cache.append(p_preload->resolved_path);
}

void GDScriptCPPGen::gen_return(const GDScriptParser::ReturnNode *p_return) {
	current->push_include_buffer(get_include(p_return->get_datatype()));
	current->push_buffer("return");
	if (p_return->return_value) {
		current->push_buffer(" ");
		gen_expression(p_return->return_value);
	}
	current->end_line_buffer();
}

void GDScriptCPPGen::gen_self(const GDScriptParser::SelfNode *p_self) {
	current->push_buffer("this");
	if (p_self->current_class->identifier) {
		current->push_buffer("->");
		gen_identifier(p_self->current_class->identifier, false);
	}
}

void GDScriptCPPGen::gen_statement(const GDScriptParser::Node *p_statement) {
	current->push_include_buffer(get_include(p_statement->get_datatype()));
	current->push_buffer("// Line:" + itos(p_statement->start_line) + "\n");

	switch (p_statement->type) {
		case GDScriptParser::Node::VARIABLE:
			gen_variable(static_cast<const GDScriptParser::VariableNode *>(p_statement));
			return;
		case GDScriptParser::Node::CONSTANT:
			gen_constant(static_cast<const GDScriptParser::ConstantNode *>(p_statement));
			return;
		case GDScriptParser::Node::IF:
			gen_if(static_cast<const GDScriptParser::IfNode *>(p_statement));
			return;
		case GDScriptParser::Node::FOR:
			gen_for(static_cast<const GDScriptParser::ForNode *>(p_statement));
			return;
		case GDScriptParser::Node::WHILE:
			gen_while(static_cast<const GDScriptParser::WhileNode *>(p_statement));
			return;
		case GDScriptParser::Node::MATCH:
			gen_match(static_cast<const GDScriptParser::MatchNode *>(p_statement));
			return;
		case GDScriptParser::Node::RETURN:
			gen_return(static_cast<const GDScriptParser::ReturnNode *>(p_statement));
			return;
		case GDScriptParser::Node::BREAK:
			current->push_buffer("break");
			current->end_line_buffer();
			return;
		case GDScriptParser::Node::CONTINUE:
			current->push_buffer("continue");
			current->end_line_buffer();
			return;
		case GDScriptParser::Node::ASSERT:
			current->push_buffer("// ASSERT");
			return;
		case GDScriptParser::Node::PASS:
			current->push_buffer("// PASS");
			return;
		case GDScriptParser::Node::BREAKPOINT:
			current->push_buffer("// BREAKPOINT");
			return;
		case GDScriptParser::Node::ASSIGNMENT:
			gen_assignment(static_cast<const GDScriptParser::AssignmentNode *>(p_statement));
			return;
		default:
			if (p_statement->is_expression()) {
				gen_expression(static_cast<const GDScriptParser::ExpressionNode *>(p_statement));
				current->end_line_buffer();
			}
			return;
	}
}

void GDScriptCPPGen::gen_subscript(const GDScriptParser::SubscriptNode *p_subscript, bool may_have_first_class_method, bool use_getter) {
	current->push_include_buffer(get_include(p_subscript->get_datatype()));
	GDScriptParser::DataType base_datatype = p_subscript->base->get_datatype();

	// first class methods
	if (may_have_first_class_method && p_subscript->is_attribute && is_method(base_datatype, static_cast<const GDScriptParser::IdentifierNode *>(p_subscript->attribute)->name)) {
		String attribute = static_cast<const GDScriptParser::IdentifierNode *>(p_subscript->attribute)->name;
		current->push_include_buffer("<godot_cpp/variant/callable.hpp>");
		current->push_buffer("Callable(");

		gen_expression(p_subscript->base, false);
		switch (get_access_type(base_datatype, attribute)) {
			case GDScriptCPPGen::AccessType::REFCOUNTED_ACCESS:
				current->push_buffer(".ptr()");
				break;
			default:
				break;
		}
		current->push_buffer(", \"");
		current->push_buffer(attribute);
		current->push_buffer("\")");
		return;
	}

	bool is_variant = base_datatype.kind == GDScriptParser::DataType::VARIANT;
	if (use_getter && is_variant && !p_subscript->is_attribute) {
		if (p_subscript->index->type == GDScriptParser::Node::LITERAL && ((static_cast<GDScriptParser::LiteralNode *>(p_subscript->index))->value.get_type() == Variant::INT || (static_cast<GDScriptParser::LiteralNode *>(p_subscript->index))->value.get_type() == Variant::FLOAT)) {
			current->push_buffer("get_indexed(");
		} else {
			current->push_buffer("get_keyed(");
		}
	}

	if (p_subscript->base->type == GDScriptParser::Node::IDENTIFIER) {
		String literal = static_cast<const GDScriptParser::IdentifierNode *>(p_subscript->base)->name;

		if (base_datatype.class_type && base_datatype.class_type->identifier && String(base_datatype.class_type->identifier->name) == literal) {
			current->push_buffer(get_datatype_name(p_subscript->base->get_datatype()));
		} else {
			gen_expression(p_subscript->base, false);
		}

		if (!p_subscript->base->get_datatype().native_type.is_empty() && Engine::get_singleton()->has_singleton(literal)) {
			current->push_buffer("::get_singleton()");
		}
	} else {
		gen_expression(p_subscript->base, false);
	}

	bool is_call = !may_have_first_class_method;
	if (p_subscript->is_attribute) {
		String attribute = static_cast<const GDScriptParser::IdentifierNode *>(p_subscript->attribute)->name;
		switch (get_access_type(base_datatype, attribute)) {
			case GDScriptCPPGen::AccessType::REFCOUNTED_ACCESS:
			case GDScriptCPPGen::AccessType::OBJECT_ACCESS:
				current->push_buffer("->");
				break;
			case GDScriptCPPGen::AccessType::SCOPE_ACCESS:
				current->push_buffer("::");
				break;
			default:
				current->push_buffer(".");
				break;
		}
		String property_getter = get_property_getter_if_property(base_datatype, attribute);
		if (use_getter && !property_getter.is_empty()) {
			current->push_buffer(property_getter + "()");
		} else if (base_datatype.class_type && base_datatype.class_type->has_member(attribute) && base_datatype.class_type->get_member(attribute).type == GDScriptParser::ClassNode::Member::CLASS) {
			current->push_buffer(get_class_name(static_cast<GDScriptParser::ClassNode *>(base_datatype.class_type->get_member(attribute).get_source_node())));
		} else {
			if (use_getter && is_variant && !is_call) {
				current->push_buffer("get(\"");
			}
			current->push_buffer(attribute);
			if (use_getter && is_variant && !is_call) {
				current->push_buffer("\")");
			}
		}
	} else {
		if (use_getter && is_variant) {
			current->push_buffer(", ");
		} else {
			current->push_buffer("[");
		}
		gen_expression(p_subscript->index);
		if (use_getter && is_variant) {
			current->push_buffer(")");
		} else {
			current->push_buffer("]");
		}
	}
}

void GDScriptCPPGen::gen_suite(const GDScriptParser::SuiteNode *p_suite) {
	for (int i = 0; i < p_suite->statements.size(); i++) {
		gen_statement(p_suite->statements[i]);
	}
}

void GDScriptCPPGen::gen_ternary_op(const GDScriptParser::TernaryOpNode *p_ternary_op) {
	current->push_buffer("(");
	gen_expression(p_ternary_op->condition);
	current->push_buffer(") ? ");
	gen_expression(p_ternary_op->true_expr);
	current->push_buffer(" : ");
	gen_expression(p_ternary_op->false_expr);
}

void GDScriptCPPGen::gen_type(const GDScriptParser::TypeNode *p_type) {
	if (p_type->type_chain.is_empty()) {
		current->push_buffer("void");
	} else {
		current->push_include_buffer(get_include(p_type->type_chain[p_type->type_chain.size() - 1]->get_datatype()));
		current->push_buffer(get_datatype_name(p_type->type_chain[p_type->type_chain.size() - 1]->get_datatype()));
	}
}

void GDScriptCPPGen::gen_type_test(const GDScriptParser::TypeTestNode *p_type) {
	if (p_type->is_constant) {
		current->push_buffer(p_type->reduced_value.booleanize() ? "(true)" : "(false)");
		return;
	}
	current->push_include_buffer("<godot_cpp/classes/object.hpp>");
	current->push_buffer("(Object::cast_to<");
	gen_type(p_type->test_type);
	current->push_buffer(">(");
	gen_expression(p_type->operand);
	current->push_buffer(") != nullptr)");
}

void GDScriptCPPGen::gen_unary_op(const GDScriptParser::UnaryOpNode *p_unary_op) {
	bool is_variant = p_unary_op->operand->get_datatype().kind == GDScriptParser::DataType::VARIANT;
	switch (p_unary_op->operation) {
		case GDScriptParser::UnaryOpNode::OP_POSITIVE:
			if (is_variant) {
				current->push_buffer("unary_op(UnaryOp::POSITIVE, ");
				break;
			}
			current->push_buffer("+");
			break;
		case GDScriptParser::UnaryOpNode::OP_NEGATIVE:
			if (is_variant) {
				current->push_buffer("unary_op(UnaryOp::NEGATIVE, ");
				break;
			}
			current->push_buffer("-");
			break;
		case GDScriptParser::UnaryOpNode::OP_LOGIC_NOT:
			if (is_variant) {
				current->push_buffer("unary_op(UnaryOp::LOGIC_NOT, ");
				break;
			}
			current->push_buffer("!");
			break;
		case GDScriptParser::UnaryOpNode::OP_COMPLEMENT:
			if (is_variant) {
				current->push_buffer("unary_op(UnaryOp::COMPLEMENT, ");
				break;
			}
			current->push_buffer("~");
			break;
	}
	gen_expression(p_unary_op->operand);
	if (is_variant) {
		current->push_buffer(")");
	}
}

void GDScriptCPPGen::gen_variable(const GDScriptParser::VariableNode *p_variable) {
	int initial_size = current->source_code_buffer.size();

	current->push_include_buffer(get_include(p_variable->get_datatype()));
	if (p_variable->is_static) {
		current->push_buffer("inline static ");
	}

	switch (get_access_type(p_variable->get_datatype())) {
		case GDScriptCPPGen::AccessType::REFCOUNTED_ACCESS:
			current->push_buffer("Ref<" + get_datatype_name(p_variable->get_datatype()) + "> ");
			break;
		case GDScriptCPPGen::AccessType::OBJECT_ACCESS:
			current->push_buffer(get_datatype_name(p_variable->get_datatype()) + " *");
			break;
		default:
			current->push_buffer(get_datatype_name(p_variable->get_datatype()) + " ");
			break;
	}

	gen_identifier(p_variable->identifier, false, false);
	if (!p_variable->onready && p_variable->initializer) {
		current->push_buffer(" = ");
		if (get_datatype_name(p_variable->get_datatype()).begins_with("TypedDictionary")) {
			current->push_buffer(get_datatype_name(p_variable->get_datatype()) + "(");
		}
		gen_expression(p_variable->initializer);

		// MetaClass (stored)
		if (current->source_code_buffer.ends_with(get_datatype_name(p_variable->get_datatype()))) {
			if (p_variable->is_static) {
				current->push_buffer("inline static ");
			}
			current->source_code_buffer = current->source_code_buffer.left(initial_size - 1);
			current->push_buffer("Variant ");
			gen_identifier(p_variable->identifier, false, false);
			current->push_buffer(" = memnew(MetaClass<");
			gen_expression(p_variable->initializer);
			current->push_buffer(">)");
			current->end_line_buffer();
			return;
		}

		if (get_datatype_name(p_variable->get_datatype()).begins_with("TypedDictionary")) {
			current->push_buffer(")");
		}
	}
	current->end_line_buffer();
}

void GDScriptCPPGen::gen_while(const GDScriptParser::WhileNode *p_while) {
	current->push_buffer("while (");
	gen_expression(p_while->condition);
	current->push_buffer(") {\n");
	current->increment_indent_level_buffer();
	gen_suite(p_while->loop);
	current->decrement_indent_level_buffer();
	current->push_buffer("}\n");
}

void GDScriptCPPGen::_bind_methods() {
	ClassDB::bind_method(D_METHOD("generate", "file_path"), &GDScriptCPPGen::generate);
}
